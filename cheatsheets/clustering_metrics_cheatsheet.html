<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ú–µ—Ç—Ä–∏–∫–∏ –æ—Ü–µ–Ω–∫–∏ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏ Cheatsheet ‚Äî 3 –∫–æ–ª–æ–Ω–∫–∏</title>
  <style>
    @media screen { body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; color: #333; background: #fafcff; padding: 10px; 
        min-width: 900px;
      }}
        .container {
      max-width: 100%;
    }

    /* Responsive columns: 3 columns on wide screens, fewer on narrow */
    @media (min-width: 900px) {
      .container {
        column-count: 3;
        column-gap: 20px;
      }
    }
    
    @media (min-width: 600px) and (max-width: 899px) {
      .container {
        column-count: 2;
        column-gap: 20px;
      }
    }
    
    @media (max-width: 599px) {
      .container {
        column-count: 1;
      }
    }
    .block { break-inside: avoid; margin-bottom: 1.2em; padding: 12px; background: white; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
    h1 { font-size: 1.6em; font-weight: 700; color: #1a5fb4; text-align: center; margin: 0 0 8px; column-span: all; }
    .subtitle { text-align: center; color: #666; font-size: 0.9em; margin-bottom: 12px; column-span: all; }
    h2 { font-size: 1.15em; font-weight: 700; color: #1a5fb4; margin: 0 0 8px; padding-bottom: 4px; border-bottom: 1px solid #e0e7ff; }
    p, ul, ol { font-size: 0.92em; margin: 0.6em 0; }
    ul, ol { padding-left: 18px; }
    li { margin-bottom: 4px; }
    code { font-family: 'Consolas', 'Courier New', monospace; background-color: #f0f4ff; padding: 1px 4px; border-radius: 3px; font-size: 0.88em; }
    pre { background-color: #f0f4ff; padding: 8px; border-radius: 4px; overflow-x: auto; font-size: 0.84em; margin: 6px 0; }
    pre code { padding: 0; background: none; white-space: pre-wrap; }
    table { width: 100%; border-collapse: collapse; font-size: 0.82em; margin: 6px 0; }
    th { background-color: #e6f0ff; text-align: left; padding: 4px 6px; font-weight: 600; }
    td { padding: 4px 6px; border-bottom: 1px solid #f0f4ff; }
    tr:nth-child(even) { background-color: #f8fbff; }
  </style>
</head>
<body>
<div class="container">
  <h1>üéØ –ú–µ—Ç—Ä–∏–∫–∏ –æ—Ü–µ–Ω–∫–∏ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏</h1>
  <div class="subtitle"></div>

  <div class="block">
    <h2>üî∑ 1. –¢–∏–ø—ã –º–µ—Ç—Ä–∏–∫ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏</h2>
    <ul>
      <li><strong>–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏</strong>: –æ—Ü–µ–Ω–∫–∞ –±–µ–∑ –∏—Å—Ç–∏–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫
        <ul>
          <li>Silhouette Score</li>
          <li>Davies-Bouldin Index</li>
          <li>Calinski-Harabasz Index</li>
          <li>Inertia / Within-cluster sum of squares</li>
        </ul>
      </li>
      <li><strong>–í–Ω–µ—à–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏</strong>: —Ç—Ä–µ–±—É—é—Ç –∏—Å—Ç–∏–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
        <ul>
          <li>Adjusted Rand Index (ARI)</li>
          <li>Adjusted Mutual Information (AMI)</li>
          <li>Normalized Mutual Information (NMI)</li>
          <li>Fowlkes-Mallows Index</li>
          <li>Homogeneity, Completeness, V-measure</li>
        </ul>
      </li>
    </ul>

  <div class="block">
    <h2>üî∑ 2. Silhouette Score</h2>
    <p><strong>–î–∏–∞–ø–∞–∑–æ–Ω</strong>: [-1, 1], –≤—ã—à–µ = –ª—É—á—à–µ</p>
    <p><strong>–§–æ—Ä–º—É–ª–∞</strong>: s = (b - a) / max(a, b)</p>
    <ul>
      <li>a: —Å—Ä–µ–¥–Ω–µ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ç–æ—á–µ–∫ —Å–≤–æ–µ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞</li>
      <li>b: —Å—Ä–µ–¥–Ω–µ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ç–æ—á–µ–∫ –±–ª–∏–∂–∞–π—à–µ–≥–æ –¥—Ä—É–≥–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞</li>
    </ul>
    <pre><code>from sklearn.metrics import silhouette_score, silhouette_samples
import matplotlib.pyplot as plt

# –û–±—â–∏–π score
score = silhouette_score(X, labels)
print(f"Silhouette Score: {score:.3f}")

# –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è:
# > 0.7: –æ—Ç–ª–∏—á–Ω–æ, —á–µ—Ç–∫–∏–µ –∫–ª–∞—Å—Ç–µ—Ä—ã
# 0.5-0.7: —Ö–æ—Ä–æ—à–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ
# 0.25-0.5: —Å—Ä–µ–¥–Ω–µ, –µ—Å—Ç—å –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏—è
# < 0.25: –ø–ª–æ—Ö–æ, –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è

# Silhouette –¥–ª—è –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏
sample_scores = silhouette_samples(X, labels)

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è silhouette plot
def plot_silhouette(X, labels):
    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)
    
    fig, ax = plt.subplots(figsize=(10, 6))
    y_lower = 10
    
    for i in range(n_clusters):
        cluster_scores = sample_scores[labels == i]
        cluster_scores.sort()
        
        size = cluster_scores.shape[0]
        y_upper = y_lower + size
        
        ax.fill_betweenx(np.arange(y_lower, y_upper),
                        0, cluster_scores,
                        alpha=0.7, label=f'Cluster {i}')
        
        y_lower = y_upper + 10
    
    ax.set_xlabel('Silhouette Coefficient')
    ax.set_ylabel('Cluster')
    ax.axvline(x=score, color='red', linestyle='--',
              label=f'Mean: {score:.3f}')
    ax.legend()
    ax.set_title('Silhouette Plot')
    plt.show()

plot_silhouette(X, labels)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 3. Davies-Bouldin Index</h2>
    <p><strong>–î–∏–∞–ø–∞–∑–æ–Ω</strong>: [0, ‚àû), –Ω–∏–∂–µ = –ª—É—á—à–µ</p>
    <p><strong>–ò–¥–µ—è</strong>: –æ—Ç–Ω–æ—à–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏-–∫–ª–∞—Å—Ç–µ—Ä–Ω—ã—Ö —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –∫ –º–µ–∂–¥—É-–∫–ª–∞—Å—Ç–µ—Ä–Ω—ã–º</p>
    <pre><code>from sklearn.metrics import davies_bouldin_score

db = davies_bouldin_score(X, labels)
print(f"Davies-Bouldin Index: {db:.3f}")

# –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è:
# < 0.5: –æ—Ç–ª–∏—á–Ω–æ
# 0.5-1.0: —Ö–æ—Ä–æ—à–æ
# 1.0-2.0: –ø—Ä–∏–µ–º–ª–µ–º–æ
# > 2.0: –ø–ª–æ—Ö–æ

# –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–ª—è —Ä–∞–∑–Ω–æ–≥–æ —á–∏—Å–ª–∞ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
from sklearn.cluster import KMeans

db_scores = []
K_range = range(2, 11)

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42)
    labels = kmeans.fit_predict(X)
    db = davies_bouldin_score(X, labels)
    db_scores.append(db)

plt.figure(figsize=(10, 5))
plt.plot(K_range, db_scores, marker='o', linewidth=2)
plt.xlabel('Number of Clusters')
plt.ylabel('Davies-Bouldin Index')
plt.title('Davies-Bouldin Index vs Number of Clusters')
plt.grid(alpha=0.3)
plt.show()

optimal_k = K_range[np.argmin(db_scores)]
print(f"Optimal K (lowest DB): {optimal_k}")</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 4. Calinski-Harabasz Index</h2>
    <p><strong>–î–∏–∞–ø–∞–∑–æ–Ω</strong>: [0, ‚àû), –≤—ã—à–µ = –ª—É—á—à–µ</p>
    <p><strong>–¢–∞–∫–∂–µ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è</strong>: Variance Ratio Criterion</p>
    <pre><code>from sklearn.metrics import calinski_harabasz_score

ch = calinski_harabasz_score(X, labels)
print(f"Calinski-Harabasz: {ch:.1f}")

# –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è:
# –ß–µ–º –≤—ã—à–µ, —Ç–µ–º –ø–ª–æ—Ç–Ω–µ–µ –∏ –ª—É—á—à–µ —Ä–∞–∑–¥–µ–ª–µ–Ω—ã –∫–ª–∞—Å—Ç–µ—Ä—ã
# –ó–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –∏ —á–∏—Å–ª–∞ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤

# –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–∞–∑–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
from sklearn.cluster import DBSCAN, AgglomerativeClustering

algorithms = {
    'K-Means': KMeans(n_clusters=3),
    'DBSCAN': DBSCAN(eps=0.5),
    'Hierarchical': AgglomerativeClustering(n_clusters=3)
}

results = {}
for name, algo in algorithms.items():
    labels = algo.fit_predict(X)
    if len(set(labels)) > 1:  # –ë–æ–ª—å—à–µ 1 –∫–ª–∞—Å—Ç–µ—Ä–∞
        ch = calinski_harabasz_score(X, labels)
        results[name] = ch
    else:
        results[name] = 0

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
plt.figure(figsize=(10, 5))
plt.bar(results.keys(), results.values(), alpha=0.7)
plt.ylabel('Calinski-Harabasz Score')
plt.title('Algorithm Comparison')
plt.xticks(rotation=15)
plt.grid(axis='y', alpha=0.3)
plt.show()</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 5. Adjusted Rand Index (ARI)</h2>
    <p><strong>–¢—Ä–µ–±—É–µ—Ç</strong>: –∏—Å—Ç–∏–Ω–Ω—ã–µ –º–µ—Ç–∫–∏. <strong>–î–∏–∞–ø–∞–∑–æ–Ω</strong>: [-1, 1]</p>
    <pre><code>from sklearn.metrics import adjusted_rand_score

ari = adjusted_rand_score(true_labels, pred_labels)
print(f"ARI: {ari:.3f}")

# –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è:
# 1.0: –∏–¥–µ–∞–ª—å–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
# > 0.9: –æ—Ç–ª–∏—á–Ω–æ–µ
# 0.5-0.9: —Ö–æ—Ä–æ—à–µ–µ
# 0.0: —Å–ª—É—á–∞–π–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
# < 0.0: —Ö—É–∂–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ

# –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å Rand Index
from sklearn.metrics import rand_score

rand = rand_score(true_labels, pred_labels)
print(f"Rand Index: {rand:.3f}")
print(f"ARI: {ari:.3f}")

# ARI –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ—Ç –Ω–∞ —Å–ª—É—á–∞–π–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 6. Mutual Information –º–µ—Ç—Ä–∏–∫–∏</h2>
    <pre><code>from sklearn.metrics import (
    adjusted_mutual_info_score,
    normalized_mutual_info_score,
    mutual_info_score
)

# Adjusted Mutual Information (—Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è)
ami = adjusted_mutual_info_score(true_labels, pred_labels)

# Normalized Mutual Information
nmi = normalized_mutual_info_score(true_labels, pred_labels)

# Mutual Information (—Å—ã—Ä–∞—è)
mi = mutual_info_score(true_labels, pred_labels)

print(f"AMI: {ami:.3f}")
print(f"NMI: {nmi:.3f}")
print(f"MI: {mi:.3f}")

# –í—Å–µ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [0, 1] (–∏–ª–∏ [-1, 1] –¥–ª—è AMI)
# –í—ã—à–µ = –ª—É—á—à–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ —Å –∏—Å—Ç–∏–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 7. Homogeneity, Completeness, V-measure</h2>
    <pre><code>from sklearn.metrics import (
    homogeneity_score,
    completeness_score,
    v_measure_score,
    homogeneity_completeness_v_measure
)

# Homogeneity: –∫–∞–∂–¥—ã–π –∫–ª–∞—Å—Ç–µ—Ä —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –∫–ª–∞—Å—Å
homogeneity = homogeneity_score(true_labels, pred_labels)

# Completeness: –≤—Å–µ —á–ª–µ–Ω—ã –∫–ª–∞—Å—Å–∞ –≤ –æ–¥–Ω–æ–º –∫–ª–∞—Å—Ç–µ—Ä–µ
completeness = completeness_score(true_labels, pred_labels)

# V-measure: –≥–∞—Ä–º–æ–Ω–∏—á–µ—Å–∫–æ–µ —Å—Ä–µ–¥–Ω–µ–µ homogeneity –∏ completeness
v_measure = v_measure_score(true_labels, pred_labels)

# –ò–ª–∏ –≤—Å–µ —Å—Ä–∞–∑—É:
h, c, v = homogeneity_completeness_v_measure(
    true_labels, pred_labels
)

print(f"Homogeneity: {h:.3f}")
print(f"Completeness: {c:.3f}")
print(f"V-measure: {v:.3f}")

# –í—Å–µ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [0, 1], –≤—ã—à–µ = –ª—É—á—à–µ</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 8. Elbow Method –∏ Inertia</h2>
    <pre><code>from sklearn.cluster import KMeans

# Inertia: —Å—É–º–º–∞ –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –¥–æ —Ü–µ–Ω—Ç—Ä–æ–∏–¥–æ–≤
inertias = []
silhouettes = []
K_range = range(2, 11)

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(X)
    inertias.append(kmeans.inertia_)
    silhouettes.append(silhouette_score(X, kmeans.labels_))

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è Elbow Method
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Inertia
axes[0].plot(K_range, inertias, marker='o', linewidth=2)
axes[0].set_xlabel('Number of Clusters (K)')
axes[0].set_ylabel('Inertia')
axes[0].set_title('Elbow Method')
axes[0].grid(alpha=0.3)

# Silhouette
axes[1].plot(K_range, silhouettes, marker='s', 
            linewidth=2, color='green')
axes[1].set_xlabel('Number of Clusters (K)')
axes[1].set_ylabel('Silhouette Score')
axes[1].set_title('Silhouette Score vs K')
axes[1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# –ü–æ–∏—Å–∫ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ K
# 1. –ü–æ Elbow (–≤–∏–∑—É–∞–ª—å–Ω–æ)
# 2. –ü–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–º—É Silhouette
optimal_k_silhouette = K_range[np.argmax(silhouettes)]
print(f"Optimal K (max silhouette): {optimal_k_silhouette}")</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 9. –°—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –º–µ—Ç—Ä–∏–∫</h2>
    <table style="font-size: 0.75em;">
      <tr>
        <th>–ú–µ—Ç—Ä–∏–∫–∞</th>
        <th>–¢—Ä–µ–±—É–µ—Ç –º–µ—Ç–∫–∏</th>
        <th>–î–∏–∞–ø–∞–∑–æ–Ω</th>
        <th>–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è</th>
        <th>–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å</th>
      </tr>
      <tr>
        <td>Silhouette</td>
        <td>–ù–µ—Ç</td>
        <td>[-1, 1]</td>
        <td>–í—ã—à–µ = –ª—É—á—à–µ</td>
        <td>–û–±—â–∞—è –æ—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞</td>
      </tr>
      <tr>
        <td>Davies-Bouldin</td>
        <td>–ù–µ—Ç</td>
        <td>[0, ‚àû)</td>
        <td>–ù–∏–∂–µ = –ª—É—á—à–µ</td>
        <td>–°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–∞–∑–Ω—ã—Ö K</td>
      </tr>
      <tr>
        <td>Calinski-Harabasz</td>
        <td>–ù–µ—Ç</td>
        <td>[0, ‚àû)</td>
        <td>–í—ã—à–µ = –ª—É—á—à–µ</td>
        <td>–ü–ª–æ—Ç–Ω–æ—Å—Ç—å –∫–ª–∞—Å—Ç–µ—Ä–æ–≤</td>
      </tr>
      <tr>
        <td>ARI</td>
        <td>–î–∞</td>
        <td>[-1, 1]</td>
        <td>–í—ã—à–µ = –ª—É—á—à–µ</td>
        <td>–°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å ground truth</td>
      </tr>
      <tr>
        <td>AMI/NMI</td>
        <td>–î–∞</td>
        <td>[0, 1]</td>
        <td>–í—ã—à–µ = –ª—É—á—à–µ</td>
        <td>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ —Å—Ö–æ–¥—Å—Ç–≤–æ</td>
      </tr>
      <tr>
        <td>V-measure</td>
        <td>–î–∞</td>
        <td>[0, 1]</td>
        <td>–í—ã—à–µ = –ª—É—á—à–µ</td>
        <td>–ë–∞–ª–∞–Ω—Å homogeneity/completeness</td>
      </tr>
    </table>
  </div>

  <div class="block">
    <h2>üî∑ 10. –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏</h2>
    <pre><code>def comprehensive_evaluation(X, labels, true_labels=None):
    """–ü–æ–ª–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏"""
    
    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)
    n_noise = list(labels).count(-1)
    
    print("=" * 50)
    print("–û–¶–ï–ù–ö–ê –ö–õ–ê–°–¢–ï–†–ò–ó–ê–¶–ò–ò")
    print("=" * 50)
    
    # –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
    print(f"
–ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:")
    print(f"  –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤: {n_clusters}")
    print(f"  –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —à—É–º–æ–≤—ã—Ö —Ç–æ—á–µ–∫: {n_noise}")
    print(f"  –†–∞–∑–º–µ—Ä –∫–∞–∂–¥–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞:")
    for i in set(labels):
        if i != -1:
            count = list(labels).count(i)
            print(f"    –ö–ª–∞—Å—Ç–µ—Ä {i}: {count} —Ç–æ—á–µ–∫")
    
    # –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏
    if n_clusters > 1:
        print(f"
–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏ (–±–µ–∑ –º–µ—Ç–æ–∫):")
        
        sil = silhouette_score(X, labels)
        print(f"  Silhouette Score: {sil:.3f}")
        if sil > 0.7:
            print(f"    ‚Üí –û—Ç–ª–∏—á–Ω–æ!")
        elif sil > 0.5:
            print(f"    ‚Üí –•–æ—Ä–æ—à–æ")
        elif sil > 0.25:
            print(f"    ‚Üí –°—Ä–µ–¥–Ω–µ")
        else:
            print(f"    ‚Üí –ü–ª–æ—Ö–æ")
        
        db = davies_bouldin_score(X, labels)
        print(f"  Davies-Bouldin Index: {db:.3f}")
        if db < 0.5:
            print(f"    ‚Üí –û—Ç–ª–∏—á–Ω–æ!")
        elif db < 1.0:
            print(f"    ‚Üí –•–æ—Ä–æ—à–æ")
        else:
            print(f"    ‚Üí –ù—É–∂–¥–∞–µ—Ç—Å—è –≤ —É–ª—É—á—à–µ–Ω–∏–∏")
        
        ch = calinski_harabasz_score(X, labels)
        print(f"  Calinski-Harabasz Index: {ch:.1f}")
        print(f"    ‚Üí –í—ã—à–µ = –ª—É—á—à–µ")
    
    # –í–Ω–µ—à–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å –∏—Å—Ç–∏–Ω–Ω—ã–µ –º–µ—Ç–∫–∏)
    if true_labels is not None:
        print(f"
–í–Ω–µ—à–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏ (—Å –º–µ—Ç–∫–∞–º–∏):")
        
        ari = adjusted_rand_score(true_labels, labels)
        print(f"  ARI: {ari:.3f}")
        
        ami = adjusted_mutual_info_score(true_labels, labels)
        print(f"  AMI: {ami:.3f}")
        
        nmi = normalized_mutual_info_score(true_labels, labels)
        print(f"  NMI: {nmi:.3f}")
        
        h, c, v = homogeneity_completeness_v_measure(
            true_labels, labels
        )
        print(f"  Homogeneity: {h:.3f}")
        print(f"  Completeness: {c:.3f}")
        print(f"  V-measure: {v:.3f}")
    
    print("=" * 50)

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
comprehensive_evaluation(X, labels, true_labels)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 11. –í—ã–±–æ—Ä –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ —á–∏—Å–ª–∞ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤</h2>
    <pre><code>def find_optimal_clusters(X, max_k=10):
    """–ü–æ–∏—Å–∫ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ K –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –º–µ—Ç–æ–¥–∞–º–∏"""
    
    metrics = {
        'k': [],
        'inertia': [],
        'silhouette': [],
        'davies_bouldin': [],
        'calinski_harabasz': []
    }
    
    for k in range(2, max_k + 1):
        kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
        labels = kmeans.fit_predict(X)
        
        metrics['k'].append(k)
        metrics['inertia'].append(kmeans.inertia_)
        metrics['silhouette'].append(silhouette_score(X, labels))
        metrics['davies_bouldin'].append(davies_bouldin_score(X, labels))
        metrics['calinski_harabasz'].append(calinski_harabasz_score(X, labels))
    
    # –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    # Inertia
    axes[0, 0].plot(metrics['k'], metrics['inertia'], 
                   marker='o', linewidth=2)
    axes[0, 0].set_title('Inertia (Elbow Method)')
    axes[0, 0].set_xlabel('K')
    axes[0, 0].set_ylabel('Inertia')
    axes[0, 0].grid(alpha=0.3)
    
    # Silhouette
    axes[0, 1].plot(metrics['k'], metrics['silhouette'],
                   marker='s', linewidth=2, color='green')
    axes[0, 1].set_title('Silhouette Score')
    axes[0, 1].set_xlabel('K')
    axes[0, 1].set_ylabel('Score')
    axes[0, 1].grid(alpha=0.3)
    
    # Davies-Bouldin
    axes[1, 0].plot(metrics['k'], metrics['davies_bouldin'],
                   marker='^', linewidth=2, color='red')
    axes[1, 0].set_title('Davies-Bouldin Index')
    axes[1, 0].set_xlabel('K')
    axes[1, 0].set_ylabel('Index (lower=better)')
    axes[1, 0].grid(alpha=0.3)
    
    # Calinski-Harabasz
    axes[1, 1].plot(metrics['k'], metrics['calinski_harabasz'],
                   marker='d', linewidth=2, color='purple')
    axes[1, 1].set_title('Calinski-Harabasz Index')
    axes[1, 1].set_xlabel('K')
    axes[1, 1].set_ylabel('Index (higher=better)')
    axes[1, 1].grid(alpha=0.3)
    
    plt.tight_layout()
    plt.show()
    
    # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
    k_silhouette = metrics['k'][np.argmax(metrics['silhouette'])]
    k_db = metrics['k'][np.argmin(metrics['davies_bouldin'])]
    k_ch = metrics['k'][np.argmax(metrics['calinski_harabasz'])]
    
    print("–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–æ–µ K:")
    print(f"  –ü–æ Silhouette: {k_silhouette}")
    print(f"  –ü–æ Davies-Bouldin: {k_db}")
    print(f"  –ü–æ Calinski-Harabasz: {k_ch}")
    
    return metrics

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
metrics = find_optimal_clusters(X, max_k=10)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 12. –ß–µ–∫-–ª–∏—Å—Ç –æ—Ü–µ–Ω–∫–∏ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏</h2>
    <ol>
      <li>‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–∑–æ–≤—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ (—á–∏—Å–ª–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤, —Ä–∞–∑–º–µ—Ä—ã)</li>
      <li>‚úÖ –í—ã—á–∏—Å–ª–∏—Ç—å Silhouette Score (>0.5 —Ö–æ—Ä–æ—à–æ)</li>
      <li>‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å Davies-Bouldin Index (<1.0 —Ö–æ—Ä–æ—à–æ)</li>
      <li>‚úÖ –†–∞—Å—Å—á–∏—Ç–∞—Ç—å Calinski-Harabasz Index</li>
      <li>‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Elbow Method –¥–ª—è –≤—ã–±–æ—Ä–∞ K</li>
      <li>‚úÖ –í–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å Silhouette plot</li>
      <li>‚úÖ –ï—Å–ª–∏ –µ—Å—Ç—å –º–µ—Ç–∫–∏ - –≤—ã—á–∏—Å–ª–∏—Ç—å ARI, AMI, V-measure</li>
      <li>‚úÖ –°—Ä–∞–≤–Ω–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏–π K</li>
      <li>‚úÖ –í–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–ª–∞—Å—Ç–µ—Ä—ã (PCA/t-SNE)</li>
      <li>‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å (—Ä–∞–∑–Ω—ã–µ random_state)</li>
    </ol>
  </div>

</div>
</div>
</body>
</html>
