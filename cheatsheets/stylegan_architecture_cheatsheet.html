<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>StyleGAN Architecture Cheatsheet ‚Äî 3 –∫–æ–ª–æ–Ω–∫–∏</title>
  <style>
    @media screen {
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
        color: #333;
        background: #fafcff;
        padding: 10px;
      }
    }
    @media print {
      body {
        background: white;
        padding: 0;
      }
      @page {
        size: A4 landscape;
        margin: 10mm;
      }
    }

    .container {
      column-count: 3;
      column-gap: 20px;
      max-width: 100%;
    }

    .block {
      break-inside: avoid;
      margin-bottom: 1.2em;
      padding: 12px;
      background: white;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }

    h1 {
      font-size: 1.6em;
      font-weight: 700;
      color: #1a5fb4;
      text-align: center;
      margin: 0 0 8px;
      column-span: all;
    }

    .subtitle {
      text-align: center;
      color: #666;
      font-size: 0.9em;
      margin-bottom: 12px;
      column-span: all;
    }

    h2 {
      font-size: 1.15em;
      font-weight: 700;
      color: #1a5fb4;
      margin: 0 0 8px;
      padding-bottom: 4px;
      border-bottom: 1px solid #e0e7ff;
    }

    p, ul, ol {
      font-size: 0.92em;
      margin: 0.6em 0;
    }

    ul, ol {
      padding-left: 18px;
    }

    li {
      margin-bottom: 4px;
    }

    code {
      font-family: 'Consolas', 'Courier New', monospace;
      background-color: #f0f4ff;
      padding: 1px 4px;
      border-radius: 3px;
      font-size: 0.88em;
    }

    pre {
      background-color: #f0f4ff;
      padding: 8px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 0.84em;
      margin: 6px 0;
    }

    pre code {
      padding: 0;
      background: none;
      white-space: pre-wrap;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.82em;
      margin: 6px 0;
    }

    th {
      background-color: #e6f0ff;
      text-align: left;
      padding: 4px 6px;
      font-weight: 600;
    }

    td {
      padding: 4px 6px;
      border-bottom: 1px solid #f0f4ff;
    }

    tr:nth-child(even) {
      background-color: #f8fbff;
    }

    .good-vs-bad {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .good-vs-bad div {
      flex: 1;
      padding: 6px 8px;
      border-radius: 4px;
    }

    .good {
      background-color: #f0f9f4;
      border-left: 3px solid #2e8b57;
    }

    .bad {
      background-color: #fdf0f2;
      border-left: 3px solid #d32f2f;
    }

    .good h3, .bad h3 {
      margin: 0 0 4px;
      font-size: 1em;
      font-weight: 700;
    }

    .good ul, .bad ul {
      padding-left: 20px;
      margin: 0;
    }

    .good li::before { content: "‚úÖ "; font-weight: bold; }
    .bad li::before { content: "‚ùå "; font-weight: bold; }

    blockquote {
      font-style: italic;
      margin: 8px 0;
      padding: 6px 10px;
      background: #f8fbff;
      border-left: 2px solid #1a5fb4;
      font-size: 0.88em;
    }

    @media print {
      .container { column-gap: 12px; }
      .block { box-shadow: none; }
      code, pre, table { font-size: 0.78em; }
      h1 { font-size: 1.4em; }
      h2 { font-size: 1em; }
    }
  </style>
</head>
<body>

<div class="container">

  <h1>üé® StyleGAN Architecture Cheatsheet</h1>
  <div class="subtitle">–î–ª—è –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö ‚Ä¢ –ë–µ–∑ —Å–ª–æ–∂–Ω–æ–π –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏ ‚Ä¢ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π —Ñ–æ–∫—É—Å<br>ÔøΩÔøΩ –Ø–Ω–≤–∞—Ä—å 2026</div>

  <div class="block">
    <h2>üî∑ 1. –ß—Ç–æ —Ç–∞–∫–æ–µ StyleGAN?</h2>
    <ul>
      <li><strong>–¶–µ–ª—å</strong>: –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ñ–æ—Ç–æ—Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</li>
      <li><strong>–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å</strong>: –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ —Å—Ç–∏–ª–µ–º –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —É—Ä–æ–≤–Ω—è—Ö</li>
      <li><strong>–û—Å–Ω–æ–≤–∞</strong>: Progressive GAN + Style Transfer –∏–¥–µ–∏</li>
      <li><strong>–í–µ—Ä—Å–∏–∏</strong>: StyleGAN (2018), StyleGAN2 (2019), StyleGAN3 (2021)</li>
      <li><strong>–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ</strong>: –ª–∏—Ü–∞, –∏—Å–∫—É—Å—Å—Ç–≤–æ, –¥–∏–∑–∞–π–Ω, data augmentation</li>
    </ul>
  </div>

  <div class="block">
    <h2>üî∑ 2. –ö–ª—é—á–µ–≤—ã–µ –∏–Ω–Ω–æ–≤–∞—Ü–∏–∏</h2>
    <table>
      <tr><th>–ö–æ–º–ø–æ–Ω–µ–Ω—Ç</th><th>–û–ø–∏—Å–∞–Ω–∏–µ</th><th>–≠—Ñ—Ñ–µ–∫—Ç</th></tr>
      <tr><td><strong>Mapping Network</strong></td><td>Z ‚Üí W –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ</td><td>–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –∞—Ç—Ä–∏–±—É—Ç–æ–≤</td></tr>
      <tr><td><strong>AdaIN</strong></td><td>Adaptive Instance Normalization</td><td>–ò–Ω–∂–µ–∫—Ü–∏—è —Å—Ç–∏–ª—è</td></tr>
      <tr><td><strong>Constant Input</strong></td><td>–§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π 4√ó4 —Ç–µ–Ω–∑–æ—Ä</td><td>–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å</td></tr>
      <tr><td><strong>Style Mixing</strong></td><td>–†–∞–∑–Ω—ã–µ W –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–ª–æ–µ–≤</td><td>–ö–æ–Ω—Ç—Ä–æ–ª—å –¥–µ—Ç–∞–ª–µ–π</td></tr>
      <tr><td><strong>Stochastic Variation</strong></td><td>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —à—É–º–∞</td><td>–†–µ–∞–ª–∏–∑–º —Ç–µ–∫—Å—Ç—É—Ä</td></tr>
    </table>
  </div>

  <div class="block">
    <h2>üî∑ 3. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: Overview</h2>
    <p><strong>–ü–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö</strong>:</p>
    <ol>
      <li><strong>Latent code z</strong> ~ N(0,1), —Ä–∞–∑–º–µ—Ä 512</li>
      <li><strong>Mapping Network</strong>: z ‚Üí w (8-—Å–ª–æ–π–Ω—ã–π MLP)</li>
      <li><strong>Synthesis Network</strong>: w ‚Üí –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</li>
      <li>–ù–∞ –∫–∞–∂–¥–æ–º —Å–ª–æ–µ: <strong>AdaIN</strong> + <strong>—à—É–º</strong></li>
    </ol>
    <pre><code># –ü—Å–µ–≤–¥–æ–∫–æ–¥
z = torch.randn(1, 512)          # latent code
w = mapping_network(z)            # style code (512,)
noise = [torch.randn(...) for each layer]
image = synthesis_network(w, noise)  # (3, 1024, 1024)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 4. Mapping Network</h2>
    <p><strong>–¶–µ–ª—å</strong>: –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å Z –≤ –±–æ–ª–µ–µ "—Ä–∞–∑–¥–µ–ª–∏–º–æ–µ" –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ W</p>
    <pre><code>class MappingNetwork(nn.Module):
    def __init__(self, z_dim=512, w_dim=512, num_layers=8):
        super().__init__()
        layers = []
        for i in range(num_layers):
            in_features = z_dim if i == 0 else w_dim
            layers.append(nn.Linear(in_features, w_dim))
            layers.append(nn.LeakyReLU(0.2))
        
        self.mapping = nn.Sequential(*layers)
    
    def forward(self, z):
        # z: (batch, 512)
        w = self.mapping(z)  # (batch, 512)
        return w</code></pre>
    <ul>
      <li><strong>8 –ø–æ–ª–Ω–æ—Å–≤—è–∑–Ω—ã—Ö —Å–ª–æ—ë–≤</strong></li>
      <li><strong>LeakyReLU</strong> –∞–∫—Ç–∏–≤–∞—Ü–∏—è</li>
      <li><strong>–ù–µ—Ç –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏</strong></li>
      <li>–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç <strong>–∑–∞–ø—É—Ç–∞–Ω–Ω–æ–µ</strong> Z –≤ <strong>—Ä–∞–∑–¥–µ–ª–∏–º–æ–µ</strong> W</li>
    </ul>
  </div>

  <div class="block">
    <h2>üî∑ 5. AdaIN (Adaptive Instance Normalization)</h2>
    <p><strong>–§–æ—Ä–º—É–ª–∞</strong>:</p>
    <pre><code>AdaIN(x, y) = y_s * (x - Œº(x)) / œÉ(x) + y_b

–≥–¥–µ:
  x - feature maps
  y = (y_s, y_b) - style (scale & bias) –∏–∑ w
  Œº(x), œÉ(x) - —Å—Ä–µ–¥–Ω–µ–µ –∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ x</code></pre>
    <pre><code>class AdaIN(nn.Module):
    def __init__(self, channels, w_dim=512):
        super().__init__()
        self.norm = nn.InstanceNorm2d(channels, affine=False)
        self.style = nn.Linear(w_dim, channels * 2)
    
    def forward(self, x, w):
        # x: (batch, channels, H, W)
        # w: (batch, w_dim)
        
        style = self.style(w)  # (batch, channels*2)
        style = style.view(-1, 2, x.size(1), 1, 1)
        
        scale = style[:, 0]  # (batch, channels, 1, 1)
        bias = style[:, 1]
        
        # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è + –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
        x = self.norm(x)
        x = scale * x + bias
        
        return x</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 6. Synthesis Network</h2>
    <pre><code>class SynthesisBlock(nn.Module):
    def __init__(self, in_channels, out_channels, w_dim=512):
        super().__init__()
        self.conv1 = nn.Conv2d(in_channels, out_channels, 3, padding=1)
        self.conv2 = nn.Conv2d(out_channels, out_channels, 3, padding=1)
        
        self.adain1 = AdaIN(out_channels, w_dim)
        self.adain2 = AdaIN(out_channels, w_dim)
        
        self.activation = nn.LeakyReLU(0.2)
        
        # –î–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —à—É–º–∞
        self.noise_strength1 = nn.Parameter(torch.zeros(1))
        self.noise_strength2 = nn.Parameter(torch.zeros(1))
    
    def forward(self, x, w, noise=None):
        # Conv + noise + AdaIN + activation
        x = self.conv1(x)
        if noise is not None:
            x = x + self.noise_strength1 * noise[0]
        x = self.activation(self.adain1(x, w))
        
        x = self.conv2(x)
        if noise is not None:
            x = x + self.noise_strength2 * noise[1]
        x = self.activation(self.adain2(x, w))
        
        return x</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 7. –ü–æ–ª–Ω–∞—è StyleGAN –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞</h2>
    <pre><code>class StyleGAN(nn.Module):
    def __init__(self, z_dim=512, w_dim=512):
        super().__init__()
        self.mapping = MappingNetwork(z_dim, w_dim)
        
        # –ü–æ—Å—Ç–æ—è–Ω–Ω—ã–π –≤—Ö–æ–¥
        self.constant = nn.Parameter(torch.randn(1, 512, 4, 4))
        
        # –ë–ª–æ–∫–∏ —Å–∏–Ω—Ç–µ–∑–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
        self.blocks = nn.ModuleList([
            SynthesisBlock(512, 512, w_dim),  # 4x4 ‚Üí 4x4
            SynthesisBlock(512, 512, w_dim),  # 4x4 ‚Üí 8x8
            SynthesisBlock(512, 256, w_dim),  # 8x8 ‚Üí 16x16
            SynthesisBlock(256, 128, w_dim),  # 16x16 ‚Üí 32x32
            SynthesisBlock(128, 64, w_dim),   # 32x32 ‚Üí 64x64
            # ... –¥–æ 1024x1024
        ])
        
        self.to_rgb = nn.Conv2d(64, 3, 1)
    
    def forward(self, z, noise=None):
        w = self.mapping(z)
        
        x = self.constant.repeat(z.size(0), 1, 1, 1)
        
        for i, block in enumerate(self.blocks):
            x = F.interpolate(x, scale_factor=2, mode='bilinear')
            x = block(x, w, noise)
        
        image = self.to_rgb(x)
        return image</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 8. Style Mixing</h2>
    <p><strong>–ò–¥–µ—è</strong>: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ w –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–ª–æ—ë–≤</p>
    <ul>
      <li><strong>Coarse styles</strong> (4√ó4 - 8√ó8): –ø–æ–∑–∞, —Ñ–æ—Ä–º–∞, –æ–±—â–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞</li>
      <li><strong>Middle styles</strong> (16√ó16 - 32√ó32): —á–µ—Ä—Ç—ã –ª–∏—Ü–∞, –ø—Ä–∏—á–µ—Å–∫–∞</li>
      <li><strong>Fine styles</strong> (64√ó64 - 1024√ó1024): —Ü–≤–µ—Ç, –º–∏–∫—Ä–æ—Ç–µ–∫—Å—Ç—É—Ä—ã</li>
    </ul>
    <pre><code>def style_mixing(generator, z1, z2, crossover_point=4):
    """
    –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å w1 –¥–ª—è –ø–µ—Ä–≤—ã—Ö —Å–ª–æ—ë–≤, w2 –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö
    """
    w1 = generator.mapping(z1)
    w2 = generator.mapping(z2)
    
    x = generator.constant
    
    for i, block in enumerate(generator.blocks):
        w = w1 if i < crossover_point else w2
        x = F.interpolate(x, scale_factor=2)
        x = block(x, w, noise)
    
    return generator.to_rgb(x)

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
z1 = torch.randn(1, 512)  # –ª–∏—Ü–æ 1
z2 = torch.randn(1, 512)  # –ª–∏—Ü–æ 2
mixed = style_mixing(generator, z1, z2, crossover_point=4)
# –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç z1, –¥–µ—Ç–∞–ª–∏ –æ—Ç z2</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 9. StyleGAN2: –£–ª—É—á—à–µ–Ω–∏—è</h2>
    <ul>
      <li><strong>Weight Demodulation</strong>: –∑–∞–º–µ–Ω–∞ AdaIN</li>
      <li><strong>Path Length Regularization</strong>: –±–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–µ W –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ</li>
      <li><strong>No Progressive Growing</strong>: —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞</li>
      <li><strong>–£–±—Ä–∞–Ω—ã –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã</strong>: droplet artifacts</li>
    </ul>
    <pre><code># Weight Demodulation (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
class ModulatedConv2d(nn.Module):
    def __init__(self, in_channels, out_channels, kernel_size, w_dim):
        super().__init__()
        self.weight = nn.Parameter(
            torch.randn(out_channels, in_channels, kernel_size, kernel_size)
        )
        self.style = nn.Linear(w_dim, in_channels)
    
    def forward(self, x, w):
        batch = x.size(0)
        
        # –ú–æ–¥—É–ª—è—Ü–∏—è –≤–µ—Å–æ–≤
        style = self.style(w).view(batch, 1, -1, 1, 1)
        weight = self.weight.unsqueeze(0) * style
        
        # –î–µmod—É–ª—è—Ü–∏—è
        demod = torch.rsqrt(weight.pow(2).sum([2, 3, 4]) + 1e-8)
        weight = weight * demod.view(batch, -1, 1, 1, 1)
        
        # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–≤–µ—Ä—Ç–∫–∏ (group conv –¥–ª—è –±–∞—Ç—á–∞)
        x = x.view(1, -1, x.size(2), x.size(3))
        weight = weight.view(-1, *weight.shape[2:])
        x = F.conv2d(x, weight, padding=1, groups=batch)
        x = x.view(batch, -1, x.size(2), x.size(3))
        
        return x</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 10. StyleGAN3: Alias-Free</h2>
    <p><strong>–ü—Ä–æ–±–ª–µ–º–∞</strong>: –∞–ª–∏–∞—Å–∏–Ω–≥ –≤ upsampling ‚Üí —Ç–µ–∫—Å—Ç—É—Ä—ã "–ø—Ä–∏–ª–∏–ø–∞—é—Ç" –∫ –ø–∏–∫—Å–µ–ª—è–º</p>
    <ul>
      <li><strong>–†–µ—à–µ–Ω–∏–µ</strong>: –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏</li>
      <li><strong>Filtered operations</strong>: low-pass —Ñ–∏–ª—å—Ç—Ä—ã</li>
      <li><strong>Rotation/translation equivariance</strong></li>
      <li><strong>–†–µ–∑—É–ª—å—Ç–∞—Ç</strong>: –ø–ª–∞–≤–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è, —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã</li>
    </ul>
  </div>

  <div class="block">
    <h2>üî∑ 11. –û–±—É—á–µ–Ω–∏–µ StyleGAN</h2>
    <pre><code># –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
generator = StyleGAN()
discriminator = Discriminator()

g_optimizer = torch.optim.Adam(generator.parameters(), lr=0.002, betas=(0, 0.99))
d_optimizer = torch.optim.Adam(discriminator.parameters(), lr=0.002, betas=(0, 0.99))

# –û–±—É—á–µ–Ω–∏–µ
for epoch in range(num_epochs):
    for real_images in dataloader:
        # –û–±—É—á–µ–Ω–∏–µ –¥–∏—Å–∫—Ä–∏–º–∏–Ω–∞—Ç–æ—Ä–∞
        z = torch.randn(batch_size, 512)
        fake_images = generator(z)
        
        d_real = discriminator(real_images)
        d_fake = discriminator(fake_images.detach())
        
        d_loss = -torch.mean(d_real) + torch.mean(d_fake)
        
        # Gradient penalty (WGAN-GP)
        gp = gradient_penalty(discriminator, real_images, fake_images)
        d_loss = d_loss + 10 * gp
        
        d_optimizer.zero_grad()
        d_loss.backward()
        d_optimizer.step()
        
        # –û–±—É—á–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ (–∫–∞–∂–¥—ã–µ n_critic —à–∞–≥–æ–≤)
        if step % n_critic == 0:
            z = torch.randn(batch_size, 512)
            fake_images = generator(z)
            g_fake = discriminator(fake_images)
            
            g_loss = -torch.mean(g_fake)
            
            g_optimizer.zero_grad()
            g_loss.backward()
            g_optimizer.step()</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 12. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ</h2>
    <pre><code># –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏
import torch
import pickle

with open('stylegan2-ffhq-config-f.pkl', 'rb') as f:
    G = pickle.load(f)['G_ema'].cuda()

# –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ª–∏—Ü–∞
z = torch.randn([1, G.z_dim]).cuda()
img = G(z, None, truncation_psi=0.7)

# –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è –ª–∏—Ü–∞–º–∏
z1 = torch.randn([1, G.z_dim]).cuda()
z2 = torch.randn([1, G.z_dim]).cuda()

alphas = torch.linspace(0, 1, steps=10)
for alpha in alphas:
    z_interp = alpha * z1 + (1 - alpha) * z2
    img = G(z_interp, None, truncation_psi=0.7)
    save_image(img, f'frame_{alpha:.2f}.png')</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 13. Truncation Trick</h2>
    <p><strong>–ò–¥–µ—è</strong>: –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞</p>
    <pre><code>def truncation_trick(w, w_avg, psi=0.7):
    """
    –ü—Ä–∏–±–ª–∏–∑–∏—Ç—å w –∫ —Å—Ä–µ–¥–Ω–µ–º—É w_avg
    psi=0: w_avg (—Å—Ä–µ–¥–Ω–µ –ª–∏—Ü–æ, –≤—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ)
    psi=1: –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ w (—Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ, –≤–æ–∑–º–æ–∂–Ω—ã –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã)
    """
    return w_avg + psi * (w - w_avg)

# –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ w
w_avg = torch.zeros(512)
for _ in range(10000):
    z = torch.randn(1, 512)
    w = mapping_network(z)
    w_avg += w.squeeze()
w_avg /= 10000

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
z = torch.randn(1, 512)
w = mapping_network(z)
w_truncated = truncation_trick(w, w_avg, psi=0.7)
img = synthesis_network(w_truncated)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 14. –ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è StyleGAN</h2>
    <div class="good-vs-bad">
      <div class="good">
        <h3>‚úÖ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–∏—Ü</h3>
        <ul>
          <li>ThisPersonDoesNotExist.com</li>
          <li>–°–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞—Ç–∞—Å–µ—Ç—ã</li>
          <li>–ê–≤–∞—Ç–∞—Ä—ã, –ø–µ—Ä—Å–æ–Ω–∞–∂–∏ –∏–≥—Ä</li>
        </ul>
      </div>
      <div class="good">
        <h3>‚úÖ Image Editing</h3>
        <ul>
          <li>–ò–∑–º–µ–Ω–µ–Ω–∏–µ –≤–æ–∑—Ä–∞—Å—Ç–∞, –ø–æ–ª–∞, —ç–º–æ—Ü–∏–π</li>
          <li>StyleGAN Encoder + —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ W</li>
          <li>Semantic face editing</li>
        </ul>
      </div>
    </div>
    <div class="good-vs-bad">
      <div class="good">
        <h3>‚úÖ Art & Design</h3>
        <ul>
          <li>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ö—É–¥–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Ä–∞–±–æ—Ç</li>
          <li>–î–∏–∑–∞–π–Ω –ª–æ–≥–æ—Ç–∏–ø–æ–≤, –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤</li>
          <li>StyleGAN-NADA (text-guided)</li>
        </ul>
      </div>
      <div class="good">
        <h3>‚úÖ Data Augmentation</h3>
        <ul>
          <li>–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ training set</li>
          <li>–°–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è CV</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="block">
    <h2>üî∑ 15. –ß–µ–∫-–ª–∏—Å—Ç</h2>
    <ul>
      <li>[ ] <strong>–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ pretrained –º–æ–¥–µ–ª–∏</strong>: FFHQ, LSUN, MetFaces</li>
      <li>[ ] <strong>Truncation trick</strong>: psi=0.5-0.7 –¥–ª—è –∫–∞—á–µ—Å—Ç–≤–∞</li>
      <li>[ ] <strong>Style mixing</strong> –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è –¥–µ—Ç–∞–ª–µ–π</li>
      <li>[ ] <strong>W –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ</strong> –ª—É—á—à–µ Z –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è</li>
      <li>[ ] <strong>StyleGAN2</strong> –≤–º–µ—Å—Ç–æ StyleGAN (–º–µ–Ω—å—à–µ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤)</li>
      <li>[ ] <strong>StyleGAN3</strong> –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –∏ –≤–∏–¥–µ–æ</li>
      <li>[ ] <strong>Fine-tuning</strong> –Ω–∞ —Å–≤–æ–∏—Ö –¥–∞–Ω–Ω—ã—Ö (transfer learning)</li>
      <li>[ ] –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ <strong>GAN –∏–Ω–≤–µ—Ä—Å–∏—é</strong> –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</li>
    </ul>

    <h3>üí° –û–±—ä—è—Å–Ω–µ–Ω–∏–µ –∑–∞–∫–∞–∑—á–∏–∫—É:</h3>
    <blockquote>
      ¬´StyleGAN ‚Äî —ç—Ç–æ –∫–∞–∫ —Ö—É–¥–æ–∂–Ω–∏–∫ —Å –Ω–µ–≤–µ—Ä–æ—è—Ç–Ω—ã–º –∫–æ–Ω—Ç—Ä–æ–ª–µ–º: –æ–Ω –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ñ–æ—Ç–æ—Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ –ª–∏—Ü–∞, –ø—Ä–∏ —ç—Ç–æ–º –æ—Ç–¥–µ–ª—å–Ω–æ —É–ø—Ä–∞–≤–ª—è—è –æ–±—â–µ–π —Ñ–æ—Ä–º–æ–π, —á–µ—Ä—Ç–∞–º–∏ –ª–∏—Ü–∞ –∏ –º–µ–ª–∫–∏–º–∏ –¥–µ—Ç–∞–ª—è–º–∏ –≤—Ä–æ–¥–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –∫–æ–∂–∏. –ö–∞–∂–¥—ã–π —É—Ä–æ–≤–µ–Ω—å –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—Ç—Å—è –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ¬ª.
    </blockquote>
  </div>

</div>

</body>
</html>
