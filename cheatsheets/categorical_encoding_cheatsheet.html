<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ Cheatsheet ‚Äî 3 –∫–æ–ª–æ–Ω–∫–∏</title>
  <style>
    @media screen {
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
        color: #333;
        background: #fafcff;
        padding: 10px;
      
        min-width: 900px;
      }
    }
    @media print {
      body {
        background: white;
        padding: 0;
      }
      @page {
        size: A4 landscape;
        margin: 10mm;
      }
    }

        .container {
      max-width: 100%;
    }

    /* Responsive columns: 3 columns on wide screens, fewer on narrow */
    @media (min-width: 900px) {
      .container {
        column-count: 3;
        column-gap: 20px;
      }
    }
    
    @media (min-width: 600px) and (max-width: 899px) {
      .container {
        column-count: 2;
        column-gap: 20px;
      }
    }
    
    @media (max-width: 599px) {
      .container {
        column-count: 1;
      }
    }

    .block {
      break-inside: avoid;
      margin-bottom: 1.2em;
      padding: 12px;
      background: white;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }

    h1 {
      font-size: 1.6em;
      font-weight: 700;
      color: #1a5fb4;
      text-align: center;
      margin: 0 0 8px;
      column-span: all;
    }

    .subtitle {
      text-align: center;
      color: #666;
      font-size: 0.9em;
      margin-bottom: 12px;
      column-span: all;
    }

    h2 {
      font-size: 1.15em;
      font-weight: 700;
      color: #1a5fb4;
      margin: 0 0 8px;
      padding-bottom: 4px;
      border-bottom: 1px solid #e0e7ff;
    }

    p, ul, ol {
      font-size: 0.92em;
      margin: 0.6em 0;
    }

    ul, ol {
      padding-left: 18px;
    }

    li {
      margin-bottom: 4px;
    }

    code {
      font-family: 'Consolas', 'Courier New', monospace;
      background-color: #f0f4ff;
      padding: 1px 4px;
      border-radius: 3px;
      font-size: 0.88em;
    }

    pre {
      background-color: #f0f4ff;
      padding: 8px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 0.84em;
      margin: 6px 0;
    }

    pre code {
      padding: 0;
      background: none;
      white-space: pre-wrap;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.82em;
      margin: 6px 0;
    }

    th {
      background-color: #e6f0ff;
      text-align: left;
      padding: 4px 6px;
      font-weight: 600;
    }

    td {
      padding: 4px 6px;
      border-bottom: 1px solid #f0f4ff;
    }

    tr:nth-child(even) {
      background-color: #f8fbff;
    }

    .good-vs-bad {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .good-vs-bad div {
      flex: 1;
      padding: 6px 8px;
      border-radius: 4px;
    }

    .good {
      background-color: #f0f9f4;
      border-left: 3px solid #2e8b57;
    }

    .bad {
      background-color: #fdf0f2;
      border-left: 3px solid #d32f2f;
    }

    .good h3, .bad h3 {
      margin: 0 0 4px;
      font-size: 1em;
      font-weight: 700;
    }

    .good ul, .bad ul {
      padding-left: 20px;
      margin: 0;
    }

    .good li::before { content: "‚úÖ "; font-weight: bold; }
    .bad li::before { content: "‚ùå "; font-weight: bold; }

    blockquote {
      font-style: italic;
      margin: 8px 0;
      padding: 6px 10px;
      background: #f8fbff;
      border-left: 2px solid #1a5fb4;
      font-size: 0.88em;
    }

    @media print {
      .container { column-gap: 12px; }
      .block { box-shadow: none; }
      code, pre, table { font-size: 0.78em; }
      h1 { font-size: 1.4em; }
      h2 { font-size: 1em; }
    }
  </style>
</head>
<body>

<div class="container">

  <h1>üî§ –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤</h1>
  <div class="subtitle">üìÖ –Ø–Ω–≤–∞—Ä—å 2026</div>

  <div class="block">
    <h2>üî∑ 1. –ó–∞—á–µ–º –∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å?</h2>
    <ul>
      <li><strong>ML-–∞–ª–≥–æ—Ä–∏—Ç–º—ã</strong> —Ä–∞–±–æ—Ç–∞—é—Ç —Ç–æ–ª—å–∫–æ —Å —á–∏—Å–ª–∞–º–∏</li>
      <li><strong>–ö–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</strong>: —Ç–µ–∫—Å—Ç, –∫–∞—Ç–µ–≥–æ—Ä–∏–∏, –≥—Ä—É–ø–ø—ã</li>
      <li><strong>–ü—Ä–∏–º–µ—Ä—ã</strong>: —Ü–≤–µ—Ç, –≥–æ—Ä–æ–¥, —Ç–∏–ø –ø—Ä–æ–¥—É–∫—Ç–∞</li>
      <li><strong>–ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ</strong> –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –∫–∞—á–µ—Å—Ç–≤–∞ –º–æ–¥–µ–ª–∏</li>
    </ul>
    <p><strong>–¢–∏–ø—ã –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤:</strong></p>
    <ul>
      <li><strong>–ù–æ–º–∏–Ω–∞–ª—å–Ω—ã–µ</strong>: –Ω–µ—Ç –ø–æ—Ä—è–¥–∫–∞ (—Ü–≤–µ—Ç, –≥–æ—Ä–æ–¥)</li>
      <li><strong>–ü–æ—Ä—è–¥–∫–æ–≤—ã–µ</strong>: –µ—Å—Ç—å –ø–æ—Ä—è–¥–æ–∫ (low, medium, high)</li>
      <li><strong>–ë–∏–Ω–∞—Ä–Ω—ã–µ</strong>: –¥–≤–∞ –∑–Ω–∞—á–µ–Ω–∏—è (–¥–∞/–Ω–µ—Ç)</li>
    </ul>

    </div>
<div class="block">
    <h2>üî∑ 2. Label Encoding</h2>
    <p>–ü—Ä–æ—Å—Ç–æ–µ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ —á–∏—Å–µ–ª –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º:</p>
    <pre><code>from sklearn.preprocessing import LabelEncoder

# –ü—Ä–∏–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö
colors = ['red', 'blue', 'green', 'red', 'green']

# Label Encoding
le = LabelEncoder()
encoded = le.fit_transform(colors)
print(encoded)  # [2 0 1 2 1]

# –û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
decoded = le.inverse_transform(encoded)
print(decoded)  # ['red' 'blue' 'green' 'red' 'green']

# –ü–æ–ª—É—á–∏—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ
print(dict(zip(le.classes_, le.transform(le.classes_))))
# {'blue': 0, 'green': 1, 'red': 2}

# –î–ª—è pandas DataFrame
import pandas as pd
df = pd.DataFrame({'color': colors})
df['color_encoded'] = le.fit_transform(df['color'])</code></pre>
    <p><strong>‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º–∞:</strong> —Å–æ–∑–¥–∞—ë—Ç –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫!</p>
  </div>

  <div class="block">
    <h2>üî∑ 3. One-Hot Encoding</h2>
    <p>–°–æ–∑–¥–∞–Ω–∏–µ –±–∏–Ω–∞—Ä–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫ –¥–ª—è –∫–∞–∂–¥–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:</p>
    <pre><code>import pandas as pd
from sklearn.preprocessing import OneHotEncoder

# Pandas —Å–ø–æ—Å–æ–± (–ø—Ä–æ—â–µ)
df = pd.DataFrame({'color': ['red', 'blue', 'green', 'red']})
df_encoded = pd.get_dummies(df, columns=['color'], prefix='color')
print(df_encoded)
#    color_blue  color_green  color_red
# 0           0            0          1
# 1           1            0          0
# 2           0            1          0
# 3           0            0          1

# Sklearn —Å–ø–æ—Å–æ–±
ohe = OneHotEncoder(sparse_output=False, drop=None)
encoded = ohe.fit_transform(df[['color']])
feature_names = ohe.get_feature_names_out(['color'])

# –° —É–¥–∞–ª–µ–Ω–∏–µ–º –ø–µ—Ä–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (–∏–∑–±–µ–∂–∞—Ç—å –º—É–ª—å—Ç–∏–∫–æ–ª–ª–∏–Ω–µ–∞—Ä–Ω–æ—Å—Ç–∏)
ohe = OneHotEncoder(sparse_output=False, drop='first')
encoded = ohe.fit_transform(df[['color']])

# Pandas —Å drop_first
df_encoded = pd.get_dummies(df, columns=['color'], drop_first=True)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 4. Ordinal Encoding</h2>
    <p>–î–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π —Å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º –ø–æ—Ä—è–¥–∫–æ–º:</p>
    <pre><code>from sklearn.preprocessing import OrdinalEncoder

# –î–∞–Ω–Ω—ã–µ —Å –ø–æ—Ä—è–¥–∫–æ–º
sizes = [['small'], ['medium'], ['large'], ['small'], ['large']]

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫
encoder = OrdinalEncoder(
    categories=[['small', 'medium', 'large']]
)

encoded = encoder.fit_transform(sizes)
print(encoded)  # [[0.] [1.] [2.] [0.] [2.]]

# Pandas —Å–ø–æ—Å–æ–±
df = pd.DataFrame({'size': ['small', 'medium', 'large', 'small']})

size_mapping = {'small': 0, 'medium': 1, 'large': 2}
df['size_encoded'] = df['size'].map(size_mapping)

# –ò–ª–∏ –±–æ–ª–µ–µ –≥–∏–±–∫–æ
from pandas.api.types import CategoricalDtype

size_order = CategoricalDtype(
    categories=['small', 'medium', 'large'], 
    ordered=True
)
df['size_cat'] = df['size'].astype(size_order)
df['size_encoded'] = df['size_cat'].cat.codes</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 5. Frequency Encoding</h2>
    <p>–ó–∞–º–µ–Ω–∞ –Ω–∞ —á–∞—Å—Ç–æ—Ç—É –ø–æ—è–≤–ª–µ–Ω–∏—è:</p>
    <pre><code>import pandas as pd

df = pd.DataFrame({
    'city': ['Moscow', 'SPB', 'Moscow', 'Kazan', 'SPB', 'Moscow']
})

# –ü–æ–¥—Å—á—ë—Ç —á–∞—Å—Ç–æ—Ç
freq = df['city'].value_counts(normalize=True)
print(freq)
# Moscow    0.50
# SPB       0.33
# Kazan     0.17

# –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
df['city_freq'] = df['city'].map(freq)

# –ò–ª–∏ –ø–æ–¥—Å—á—ë—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
counts = df['city'].value_counts()
df['city_count'] = df['city'].map(counts)

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
def frequency_encoding(df, column):
    freq = df[column].value_counts(normalize=True)
    return df[column].map(freq)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 6. Target Encoding (Mean Encoding)</h2>
    <p>–ó–∞–º–µ–Ω–∞ –Ω–∞ —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ü–µ–ª–µ–≤–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π:</p>
    <pre><code>import pandas as pd
import numpy as np

# –î–∞–Ω–Ω—ã–µ
df = pd.DataFrame({
    'city': ['Moscow', 'SPB', 'Moscow', 'Kazan', 'SPB'],
    'target': [100, 80, 120, 90, 85]
})

# –ü—Ä–æ—Å—Ç–æ–π target encoding (–¢–û–õ–¨–ö–û –Ω–∞ train!)
target_mean = df.groupby('city')['target'].mean()
df['city_target_enc'] = df['city'].map(target_mean)

# –° —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏–µ–π (smoothing)
def target_encode_smooth(df, cat_col, target_col, alpha=5):
    global_mean = df[target_col].mean()
    agg = df.groupby(cat_col)[target_col].agg(['mean', 'count'])
    
    # Smoothed mean
    smooth = (agg['count'] * agg['mean'] + alpha * global_mean) / (agg['count'] + alpha)
    
    return df[cat_col].map(smooth)

df['city_smooth'] = target_encode_smooth(df, 'city', 'target', alpha=5)

# Category Encoders –±–∏–±–ª–∏–æ—Ç–µ–∫–∞
from category_encoders import TargetEncoder

te = TargetEncoder(cols=['city'])
# Fit —Ç–æ–ª—å–∫–æ –Ω–∞ train!
X_train_enc = te.fit_transform(X_train, y_train)
X_test_enc = te.transform(X_test)</code></pre>
    <p><strong>‚ö†Ô∏è –†–∏—Å–∫ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è!</strong> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ cross-validation</p>
  </div>

  <div class="block">
    <h2>üî∑ 7. Binary Encoding</h2>
    <p>–ö–æ–º–±–∏–Ω–∞—Ü–∏—è label –∏ one-hot encoding:</p>
    <pre><code>from category_encoders import BinaryEncoder

# –î–∞–Ω–Ω—ã–µ
df = pd.DataFrame({
    'city': ['Moscow', 'SPB', 'Kazan', 'Omsk', 'Moscow']
})

# Binary encoding
be = BinaryEncoder(cols=['city'])
df_encoded = be.fit_transform(df)

print(df_encoded)
#    city_0  city_1  city_2
# 0       0       0       1
# 1       0       1       0
# 2       0       1       1
# 3       1       0       0
# 4       0       0       1

# –ü–ª—é—Å—ã: –º–µ–Ω—å—à–µ –∫–æ–ª–æ–Ω–æ–∫ —á–µ–º one-hot
# –î–ª—è N –∫–∞—Ç–µ–≥–æ—Ä–∏–π —Å–æ–∑–¥–∞—ë—Ç log2(N) –∫–æ–ª–æ–Ω–æ–∫</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 8. Hash Encoding</h2>
    <p>–î–ª—è –≤—ã—Å–æ–∫–æ–∫–∞—Ä–¥–∏–Ω–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤:</p>
    <pre><code>from sklearn.feature_extraction import FeatureHasher
from category_encoders import HashingEncoder

# Category Encoders —Å–ø–æ—Å–æ–±
he = HashingEncoder(cols=['city'], n_components=8)
df_encoded = he.fit_transform(df)

# Sklearn —Å–ø–æ—Å–æ–±
hasher = FeatureHasher(n_features=8, input_type='string')
hashed = hasher.fit_transform(df['city'].values)

# –ü–ª—é—Å—ã: 
# - –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ –∫–æ–ª–æ–Ω–æ–∫
# - –ù–µ –Ω—É–∂–Ω–æ –∑–∞–ø–æ–º–∏–Ω–∞—Ç—å –≤—Å–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
# - –†–∞–±–æ—Ç–∞–µ—Ç —Å –Ω–æ–≤—ã–º–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏

# –ú–∏–Ω—É—Å—ã:
# - –í–æ–∑–º–æ–∂–Ω—ã –∫–æ–ª–ª–∏–∑–∏–∏ (—Ä–∞–∑–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ‚Üí –æ–¥–∏–Ω —Ö–µ—à)
# - –°–ª–æ–∂–Ω–µ–µ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 9. Leave-One-Out Encoding</h2>
    <p>Target encoding –±–µ–∑ —É—Ç–µ—á–∫–∏ –¥–∞–Ω–Ω—ã—Ö:</p>
    <pre><code>from category_encoders import LeaveOneOutEncoder

# –î–ª—è –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–∏ –≤—ã—á–∏—Å–ª—è–µ—Ç mean target 
# –ø–æ –≤—Å–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–º —Å—Ç—Ä–æ–∫–∞–º —Å —Ç–æ–π –∂–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π

df = pd.DataFrame({
    'city': ['Moscow', 'SPB', 'Moscow', 'SPB', 'Moscow'],
    'target': [100, 80, 120, 85, 110]
})

loo = LeaveOneOutEncoder(cols=['city'])
df_encoded = loo.fit_transform(df['city'], df['target'])

print(df_encoded)
# –î–ª—è 1-–π Moscow: —Å—Ä–µ–¥–Ω–µ–µ –ø–æ 2-–π –∏ 3-–π Moscow
# –î–ª—è 2-–π Moscow: —Å—Ä–µ–¥–Ω–µ–µ –ø–æ 1-–π –∏ 3-–π Moscow

# –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ: –º–µ–Ω—å—à–µ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è —á–µ–º –æ–±—ã—á–Ω—ã–π target encoding</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 10. –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–¥–∫–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π</h2>
    <pre><code>import pandas as pd

df = pd.DataFrame({
    'city': ['Moscow', 'SPB', 'Moscow', 'Kazan', 'Omsk', 
             'Moscow', 'Tver', 'SPB', 'Moscow']
})

# –ú–µ—Ç–æ–¥ 1: –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —Ä–µ–¥–∫–∏—Ö –≤ "Other"
def group_rare_categories(df, column, threshold=0.05):
    # –ß–∞—Å—Ç–æ—Ç–∞ –∫–∞–∂–¥–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    freq = df[column].value_counts(normalize=True)
    
    # –†–µ–¥–∫–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    rare = freq[freq < threshold].index
    
    # –ó–∞–º–µ–Ω–∞
    df[column + '_grouped'] = df[column].where(
        ~df[column].isin(rare), 
        'Other'
    )
    
    return df

df = group_rare_categories(df, 'city', threshold=0.15)

# –ú–µ—Ç–æ–¥ 2: –¢–æ–ø-N –∫–∞—Ç–µ–≥–æ—Ä–∏–π + Other
def keep_top_categories(df, column, n=5):
    top_n = df[column].value_counts().head(n).index
    df[column + '_top'] = df[column].where(
        df[column].isin(top_n), 
        'Other'
    )
    return df

df = keep_top_categories(df, 'city', n=3)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 11. –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π</h2>
    <pre><code># –ü—Ä–æ–±–ª–µ–º–∞: –≤ test –ø–æ—è–≤–ª—è—é—Ç—Å—è –Ω–æ–≤—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏

# –†–µ—à–µ–Ω–∏–µ 1: handle_unknown –≤ OneHotEncoder
from sklearn.preprocessing import OneHotEncoder

ohe = OneHotEncoder(
    handle_unknown='ignore',  # –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–µ
    sparse_output=False
)

X_train = [['Moscow'], ['SPB'], ['Kazan']]
X_test = [['Moscow'], ['NewCity']]  # –ù–æ–≤–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è

ohe.fit(X_train)
encoded_test = ohe.transform(X_test)
# NewCity –±—É–¥–µ—Ç –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ –≤—Å–µ –Ω—É–ª–∏

# –†–µ—à–µ–Ω–∏–µ 2: –ó–∞—Ä–∞–Ω–µ–µ –¥–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é "Unknown"
df['city_with_unknown'] = df['city'].cat.add_categories(['Unknown'])

# –†–µ—à–µ–Ω–∏–µ 3: –ó–∞–º–µ–Ω–∏—Ç—å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –Ω–∞ —á–∞—Å—Ç—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é
train_categories = set(X_train['city'])
X_test['city_safe'] = X_test['city'].where(
    X_test['city'].isin(train_categories),
    'Moscow'  # –°–∞–º–∞—è —á–∞—Å—Ç–∞—è –∏–∑ train
)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 12. –í—ã–±–æ—Ä –º–µ—Ç–æ–¥–∞ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è</h2>
    <table>
      <tr><th>–ú–µ—Ç–æ–¥</th><th>–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å</th><th>–ü–ª—é—Å—ã/–ú–∏–Ω—É—Å—ã</th></tr>
      <tr>
        <td><strong>Label</strong></td>
        <td>–ü–æ—Ä—è–¥–∫–æ–≤—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏, —Ç–∞—Ä–≥–µ—Ç –≤ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏</td>
        <td>‚úÖ –ü—Ä–æ—Å—Ç–æ–π<br>‚ùå –°–æ–∑–¥–∞—ë—Ç –ª–æ–∂–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫</td>
      </tr>
      <tr>
        <td><strong>One-Hot</strong></td>
        <td>–ú–∞–ª–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–π (&lt;10), –ª–∏–Ω–µ–π–Ω—ã–µ –º–æ–¥–µ–ª–∏</td>
        <td>‚úÖ –ù–µ—Ç –ª–æ–∂–Ω—ã—Ö —Å–≤—è–∑–µ–π<br>‚ùå –ú–Ω–æ–≥–æ –∫–æ–ª–æ–Ω–æ–∫</td>
      </tr>
      <tr>
        <td><strong>Ordinal</strong></td>
        <td>–ï—Å—Ç—å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫</td>
        <td>‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø–æ—Ä—è–¥–æ–∫<br>‚ùå –ù—É–∂–Ω–æ –∑–Ω–∞—Ç—å –ø–æ—Ä—è–¥–æ–∫</td>
      </tr>
      <tr>
        <td><strong>Target</strong></td>
        <td>–í—ã—Å–æ–∫–∞—è –∫–∞—Ä–¥–∏–Ω–∞–ª—å–Ω–æ—Å—Ç—å, tree-based –º–æ–¥–µ–ª–∏</td>
        <td>‚úÖ –ú–æ—â–Ω—ã–π<br>‚ùå –†–∏—Å–∫ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è</td>
      </tr>
      <tr>
        <td><strong>Frequency</strong></td>
        <td>–ö–æ–≥–¥–∞ —á–∞—Å—Ç–æ—Ç–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–∞–∂–Ω–∞</td>
        <td>‚úÖ –ü—Ä–æ—Å—Ç–æ–π<br>‚ùå –¢–µ—Ä—è–µ—Ç –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å</td>
      </tr>
      <tr>
        <td><strong>Binary</strong></td>
        <td>–°—Ä–µ–¥–Ω—è—è –∫–∞—Ä–¥–∏–Ω–∞–ª—å–Ω–æ—Å—Ç—å (10-100)</td>
        <td>‚úÖ –ö–æ–º–ø–∞–∫—Ç–Ω—ã–π<br>‚ùå –ú–µ–Ω–µ–µ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º</td>
      </tr>
      <tr>
        <td><strong>Hashing</strong></td>
        <td>–û—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è –∫–∞—Ä–¥–∏–Ω–∞–ª—å–Ω–æ—Å—Ç—å (&gt;1000)</td>
        <td>‚úÖ –§–∏–∫—Å. —Ä–∞–∑–º–µ—Ä<br>‚ùå –ö–æ–ª–ª–∏–∑–∏–∏</td>
      </tr>
    </table>
  </div>

  <div class="block">
    <h2>üî∑ 13. –õ—É—á—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏</h2>
    <div class="good-vs-bad">
      <div class="good">
        <h3>‚úÖ –î–µ–ª–∞—Ç—å</h3>
        <ul>
          <li>Fit encoding —Ç–æ–ª—å–∫–æ –Ω–∞ train –¥–∞–Ω–Ω—ã—Ö</li>
          <li>One-hot –¥–ª—è –ª–∏–Ω–µ–π–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π</li>
          <li>Target encoding –¥–ª—è gradient boosting</li>
          <li>–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ä–µ–¥–∫–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏</li>
          <li>–ü—Ä–æ–¥—É–º–∞—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –¥–ª—è –Ω–æ–≤—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π</li>
          <li>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Pipeline –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏</li>
        </ul>
      </div>
      <div class="bad">
        <h3>‚ùå –ù–µ –¥–µ–ª–∞—Ç—å</h3>
        <ul>
          <li>Fit –Ω–∞ –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö (train + test)</li>
          <li>Label encoding –¥–ª—è –Ω–æ–º–∏–Ω–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤</li>
          <li>Target encoding –±–µ–∑ cross-validation</li>
          <li>One-hot –¥–ª—è –≤—ã—Å–æ–∫–æ–π –∫–∞—Ä–¥–∏–Ω–∞–ª—å–Ω–æ—Å—Ç–∏</li>
          <li>–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤ test</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="block">
    <h2>üî∑ 14. Pipeline –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è</h2>
    <pre><code>from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.ensemble import RandomForestClassifier

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø—ã –∫–æ–ª–æ–Ω–æ–∫
cat_features = ['city', 'color']
num_features = ['price', 'age']

# –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä—ã
preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), num_features),
        ('cat', OneHotEncoder(handle_unknown='ignore'), cat_features)
    ]
)

# Pipeline
pipeline = Pipeline([
    ('preprocessor', preprocessor),
    ('classifier', RandomForestClassifier())
])

# –û–±—É—á–µ–Ω–∏–µ –∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –≤ –æ–¥–∏–Ω —à–∞–≥
pipeline.fit(X_train, y_train)
predictions = pipeline.predict(X_test)

# –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ pipeline
import joblib
joblib.dump(pipeline, 'model_pipeline.pkl')</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 15. –ß–µ–∫-–ª–∏—Å—Ç</h2>
    <ul>
      <li>[ ] –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤</li>
      <li>[ ] –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–∞—Ä–¥–∏–Ω–∞–ª—å–Ω–æ—Å—Ç—å (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö)</li>
      <li>[ ] –î–ª—è –Ω–∏–∑–∫–æ–π (&lt;10) ‚Üí One-Hot Encoding</li>
      <li>[ ] –î–ª—è —Å—Ä–µ–¥–Ω–µ–π (10-100) ‚Üí Binary/Target Encoding</li>
      <li>[ ] –î–ª—è –≤—ã—Å–æ–∫–æ–π (&gt;100) ‚Üí Target/Hash Encoding</li>
      <li>[ ] –û–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ä–µ–¥–∫–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏</li>
      <li>[ ] –ü—Ä–æ–¥—É–º–∞—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –¥–ª—è –Ω–æ–≤—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π</li>
      <li>[ ] –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Pipeline</li>
      <li>[ ] –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –º–µ—Ç—Ä–∏–∫–∏ —Å —Ä–∞–∑–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏</li>
      <li>[ ] –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥</li>
    </ul>

    <h3>üí° –û–±—ä—è—Å–Ω–µ–Ω–∏–µ –∑–∞–∫–∞–∑—á–∏–∫—É:</h3>
    <blockquote>
      ¬´–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π ‚Äî —ç—Ç–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤ —á–∏—Å–ª–∞, –ø–æ–Ω—è—Ç–Ω—ã–µ –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤. –ù–∞–ø—Ä–∏–º–µ—Ä, —Ü–≤–µ—Ç–∞ "–∫—Ä–∞—Å–Ω—ã–π", "—Å–∏–Ω–∏–π", "–∑–µ–ª—ë–Ω—ã–π" –º–æ–∂–Ω–æ –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∫ 0, 1, 2, –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–π –ø—Ä–∏–∑–Ω–∞–∫ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ü–≤–µ—Ç–∞¬ª.
    </blockquote>
  </div>



</div>
</body>
</html>
