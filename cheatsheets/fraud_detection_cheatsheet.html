<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fraud Detection (–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –º–æ—à–µ–Ω–Ω–∏—á–µ—Å—Ç–≤–∞) Cheatsheet ‚Äî 3 –∫–æ–ª–æ–Ω–∫–∏</title>
  <style>
    @media screen { body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; color: #333; background: #fafcff; padding: 10px; 
        min-width: 900px;
      } }
    @media print { body { background: white; padding: 0; } @page { size: A4 landscape; margin: 10mm; } }
        .container {
      max-width: 100%;
    }

    /* Responsive columns: 3 columns on wide screens, fewer on narrow */
    @media (min-width: 900px) {
      .container {
        column-count: 3;
        column-gap: 20px;
      }
    }
    
    @media (min-width: 600px) and (max-width: 899px) {
      .container {
        column-count: 2;
        column-gap: 20px;
      }
    }
    
    @media (max-width: 599px) {
      .container {
        column-count: 1;
      }
    }
    .block { break-inside: avoid; margin-bottom: 1.2em; padding: 12px; background: white; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
    h1 { font-size: 1.6em; font-weight: 700; color: #1a5fb4; text-align: center; margin: 0 0 8px; column-span: all; }
    .subtitle { text-align: center; color: #666; font-size: 0.9em; margin-bottom: 12px; column-span: all; }
    h2 { font-size: 1.15em; font-weight: 700; color: #1a5fb4; margin: 0 0 8px; padding-bottom: 4px; border-bottom: 1px solid #e0e7ff; }
    p, ul, ol { font-size: 0.92em; margin: 0.6em 0; }
    ul, ol { padding-left: 18px; }
    li { margin-bottom: 4px; }
    code { font-family: 'Consolas', 'Courier New', monospace; background-color: #f0f4ff; padding: 1px 4px; border-radius: 3px; font-size: 0.88em; }
    pre { background-color: #f0f4ff; padding: 8px; border-radius: 4px; overflow-x: auto; font-size: 0.84em; margin: 6px 0; }
    pre code { padding: 0; background: none; white-space: pre-wrap; }
    table { width: 100%; border-collapse: collapse; font-size: 0.82em; margin: 6px 0; }
    th { background-color: #e6f0ff; text-align: left; padding: 4px 6px; font-weight: 600; }
    td { padding: 4px 6px; border-bottom: 1px solid #f0f4ff; }
    tr:nth-child(even) { background-color: #f8fbff; }
    blockquote { font-style: italic; margin: 8px 0; padding: 6px 10px; background: #f8fbff; border-left: 2px solid #1a5fb4; font-size: 0.88em; }
    @media print { .container { column-gap: 12px; } .block { box-shadow: none; } code, pre, table { font-size: 0.78em; } h1 { font-size: 1.4em; } h2 { font-size: 1em; } }
  </style>
</head>
<body>

<div class="container">

  <h1>üö® Fraud Detection (–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –º–æ—à–µ–Ω–Ω–∏—á–µ—Å—Ç–≤–∞)</h1>
  <div class="subtitle">üìÖ –Ø–Ω–≤–∞—Ä—å 2026</div>

  <div class="block">
    <h2>üî∑ 1. –°–ø–µ—Ü–∏—Ñ–∏–∫–∞ –∑–∞–¥–∞—á–∏</h2>
<ul><li><strong>–î–∏—Å–±–∞–ª–∞–Ω—Å –∫–ª–∞—Å—Å–æ–≤</strong>: 0.1-1% –º–æ—à–µ–Ω–Ω–∏—á–µ—Å—Ç–≤–∞</li><li><strong>Real-time</strong>: —Ä–µ—à–µ–Ω–∏–µ –∑–∞ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã</li><li><strong>–ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å</strong>: –º–æ—à–µ–Ω–Ω–∏–∫–∏ –º–µ–Ω—è—é—Ç —Ç–∞–∫—Ç–∏–∫—É</li><li><strong>–¶–µ–Ω–∞ –æ—à–∏–±–∫–∏</strong>: FP –±–ª–æ–∫–∏—Ä—É–µ—Ç –∫–ª–∏–µ–Ω—Ç–æ–≤, FN —Ç–µ—Ä—è–µ—Ç –¥–µ–Ω—å–≥–∏</li><li><strong>–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å</strong>: –Ω—É–∂–Ω–æ –æ–±—ä—è—Å–Ω—è—Ç—å —Ä–µ—à–µ–Ω–∏—è</li></ul><blockquote>–í fraud detection –æ—à–∏–±–∫–∞ –ø–µ—Ä–≤–æ–≥–æ —Ä–æ–¥–∞ (false positive) –±–ª–æ–∫–∏—Ä—É–µ—Ç –ª–µ–≥–∏—Ç–∏–º–Ω–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞, –æ—à–∏–±–∫–∞ –≤—Ç–æ—Ä–æ–≥–æ —Ä–æ–¥–∞ (false negative) –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç –º–æ—à–µ–Ω–Ω–∏–∫–∞.</blockquote>

  <div class="block">
    <h2>üî∑ 2. –¢–∏–ø—ã –º–æ—à–µ–Ω–Ω–∏—á–µ—Å—Ç–≤–∞</h2>
<table><tr><th>–¢–∏–ø</th><th>–ü—Ä–∏–º–µ—Ä</th><th>–ü—Ä–∏–∑–Ω–∞–∫–∏</th></tr><tr><td>Credit card fraud</td><td>–£–∫—Ä–∞–¥–µ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞</td><td>–ù–µ–æ–±—ã—á–Ω—ã–µ —Å—É–º–º—ã, –ª–æ–∫–∞—Ü–∏—è</td></tr><tr><td>Account takeover</td><td>–í–∑–ª–æ–º –∞–∫–∫–∞—É–Ω—Ç–∞</td><td>–°–º–µ–Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞, IP</td></tr><tr><td>Payment fraud</td><td>–§–µ–π–∫–æ–≤—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏</td><td>–ü–∞—Ç—Ç–µ—Ä–Ω –ø–æ–∫—É–ø–æ–∫</td></tr><tr><td>Identity theft</td><td>–ö—Ä–∞–∂–∞ –ª–∏—á–Ω–æ—Å—Ç–∏</td><td>–ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –¥–∞–Ω–Ω—ã—Ö</td></tr><tr><td>Insurance fraud</td><td>–õ–æ–∂–Ω—ã–µ –∑–∞—è–≤–∫–∏</td><td>–°—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ –∞–Ω–æ–º–∞–ª–∏–∏</td></tr></table>
  </div>

  <div class="block">
    <h2>üî∑ 3. Feature Engineering</h2>
<pre><code># –í—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏
df["hour"] = df["timestamp"].dt.hour
df["day_of_week"] = df["timestamp"].dt.dayofweek
df["is_weekend"] = df["day_of_week"].isin([5, 6])
df["is_night"] = df["hour"].between(0, 6)

# –ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–∞ –ø–µ—Ä–∏–æ–¥
df["count_24h"] = df.groupby("user_id")["transaction"].rolling(
    window="24H", on="timestamp"
).count()
df["sum_24h"] = df.groupby("user_id")["amount"].rolling(
    window="24H", on="timestamp"
).sum()

# –û—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –æ—Ç –Ω–æ—Ä–º—ã
df["amount_zscore"] = (
    df["amount"] - df.groupby("user_id")["amount"].transform("mean")
) / df.groupby("user_id")["amount"].transform("std")

# –°–∫–æ—Ä–æ—Å—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
df["velocity"] = df.groupby("user_id")["timestamp"].diff().dt.seconds</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 4. –†–∞–±–æ—Ç–∞ —Å –¥–∏—Å–±–∞–ª–∞–Ω—Å–æ–º</h2>
<pre><code>from imblearn.over_sampling import SMOTE
from imblearn.under_sampling import RandomUnderSampler
from imblearn.pipeline import Pipeline as ImbPipeline

# SMOTE –¥–ª—è minority class
smote = SMOTE(sampling_strategy=0.1, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_train, y_train)

# –ò–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—è
over = SMOTE(sampling_strategy=0.3)
under = RandomUnderSampler(sampling_strategy=0.5)
pipeline = ImbPipeline([
    ("over", over),
    ("under", under)
])
X_res, y_res = pipeline.fit_resample(X_train, y_train)

# Class weights –¥–ª—è –º–æ–¥–µ–ª–µ–π
from sklearn.utils.class_weight import compute_class_weight
weights = compute_class_weight(
    "balanced", 
    classes=np.unique(y_train), 
    y=y_train
)
model = XGBClassifier(scale_pos_weight=weights[1]/weights[0])</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 5. –ú–æ–¥–µ–ª–∏</h2>
<pre><code># Random Forest —Å class weights
from sklearn.ensemble import RandomForestClassifier

rf = RandomForestClassifier(
    n_estimators=200,
    max_depth=10,
    class_weight="balanced",  # –≤–∞–∂–Ω–æ!
    random_state=42
)
rf.fit(X_train, y_train)

# XGBoost - —Ö–æ—Ä–æ—à–æ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –¥–∏—Å–±–∞–ª–∞–Ω—Å–æ–º
import xgboost as xgb

scale_pos_weight = len(y_train[y_train==0]) / len(y_train[y_train==1])
xgb_model = xgb.XGBClassifier(
    scale_pos_weight=scale_pos_weight,
    max_depth=6,
    learning_rate=0.1,
    n_estimators=200
)
xgb_model.fit(X_train, y_train)

# LightGBM - –±—ã—Å—Ç—Ä–µ–µ –¥–ª—è –±–æ–ª—å—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö
import lightgbm as lgb

lgb_model = lgb.LGBMClassifier(
    scale_pos_weight=scale_pos_weight,
    num_leaves=31,
    learning_rate=0.05
)
lgb_model.fit(X_train, y_train)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 6. Anomaly Detection –ø–æ–¥—Ö–æ–¥</h2>
<pre><code># Isolation Forest
from sklearn.ensemble import IsolationForest

iso_forest = IsolationForest(
    contamination=0.01,  # –æ–∂–∏–¥–∞–µ–º–∞—è –¥–æ–ª—è –∞–Ω–æ–º–∞–ª–∏–π
    random_state=42
)

# –û–±—É—á–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –Ω–∞ –Ω–æ—Ä–º–∞–ª—å–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è—Ö
X_normal = X_train[y_train == 0]
iso_forest.fit(X_normal)

# –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –∞–Ω–æ–º–∞–ª–∏–π (-1 = anomaly, 1 = normal)
predictions = iso_forest.predict(X_test)
anomalies = predictions == -1

# One-Class SVM
from sklearn.svm import OneClassSVM

ocsvm = OneClassSVM(nu=0.01, gamma="auto")
ocsvm.fit(X_normal)
predictions = ocsvm.predict(X_test)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 7. –ú–µ—Ç—Ä–∏–∫–∏</h2>
<pre><code>from sklearn.metrics import (precision_recall_fscore_support,
                             roc_auc_score, average_precision_score,
                             confusion_matrix)

# Precision, Recall, F1 (–≤–∞–∂–Ω–µ–µ accuracy!)
precision, recall, f1, _ = precision_recall_fscore_support(
    y_test, y_pred, average="binary"
)

print(f"Precision: {precision:.3f}")  # –∏–∑ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã—Ö fraud, —Å–∫–æ–ª—å–∫–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ
print(f"Recall: {recall:.3f}")        # –∏–∑ —Ä–µ–∞–ª—å–Ω—ã—Ö fraud, —Å–∫–æ–ª—å–∫–æ –Ω–∞—à–ª–∏
print(f"F1: {f1:.3f}")

# ROC AUC
roc_auc = roc_auc_score(y_test, y_pred_proba[:, 1])
print(f"ROC AUC: {roc_auc:.3f}")

# PR AUC (–ª—É—á—à–µ –¥–ª—è imbalanced)
pr_auc = average_precision_score(y_test, y_pred_proba[:, 1])
print(f"PR AUC: {pr_auc:.3f}")

# Confusion Matrix
tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()
print(f"TP: {tp}, FP: {fp}, TN: {tn}, FN: {fn}")</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 8. Threshold tuning</h2>
<pre><code># –ü–æ–¥–±–æ—Ä –ø–æ—Ä–æ–≥–∞ –¥–ª—è –±–∞–ª–∞–Ω—Å–∞ precision/recall
from sklearn.metrics import precision_recall_curve

precisions, recalls, thresholds = precision_recall_curve(
    y_test, y_pred_proba[:, 1]
)

# F1-–æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥
f1_scores = 2 * (precisions * recalls) / (precisions + recalls)
opt_idx = np.argmax(f1_scores)
opt_threshold = thresholds[opt_idx]

print(f"Optimal threshold: {opt_threshold:.3f}")

# –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ
y_pred_tuned = (y_pred_proba[:, 1] >= opt_threshold).astype(int)

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
import matplotlib.pyplot as plt
plt.plot(thresholds, precisions[:-1], label="Precision")
plt.plot(thresholds, recalls[:-1], label="Recall")
plt.axvline(opt_threshold, color="r", linestyle="--")
plt.legend()
plt.show()</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 9. Real-time scoring</h2>
<pre><code># –ü–∞–π–ø–ª–∞–π–Ω –¥–ª—è production
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler

pipeline = Pipeline([
    ("scaler", StandardScaler()),
    ("model", xgb_model)
])

# –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
import joblib
joblib.dump(pipeline, "fraud_detector.pkl")

# API –¥–ª—è real-time —Å–∫–æ—Ä–∏–Ω–≥–∞
from fastapi import FastAPI
import pandas as pd

app = FastAPI()
model = joblib.load("fraud_detector.pkl")

@app.post("/predict")
def predict(transaction: dict):
    # Feature engineering
    features = extract_features(transaction)
    X = pd.DataFrame([features])
    
    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
    fraud_probability = model.predict_proba(X)[0, 1]
    
    # –†–µ—à–µ–Ω–∏–µ
    if fraud_probability > 0.8:
        return {"decision": "BLOCK", "score": fraud_probability}
    elif fraud_probability > 0.5:
        return {"decision": "REVIEW", "score": fraud_probability}
    else:
        return {"decision": "APPROVE", "score": fraud_probability}</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 10. Interpretability</h2>
<pre><code># SHAP –¥–ª—è –æ–±—ä—è—Å–Ω–µ–Ω–∏—è
import shap

explainer = shap.TreeExplainer(xgb_model)
shap_values = explainer.shap_values(X_test)

# Visualize –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
shap.force_plot(
    explainer.expected_value,
    shap_values[0],
    X_test.iloc[0]
)

# Feature importance
shap.summary_plot(shap_values, X_test)

# –î–ª—è –±–∏–∑–Ω–µ—Å–∞: —Ç–æ–ø-3 –ø—Ä–∏—á–∏–Ω—ã
def explain_decision(transaction_idx):
    shap_val = shap_values[transaction_idx]
    feature_importance = pd.DataFrame({
        "feature": X_test.columns,
        "importance": abs(shap_val)
    }).sort_values("importance", ascending=False)
    
    return feature_importance.head(3)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 11. Online Learning</h2>
<pre><code># –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ —Å –Ω–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
from river import tree, metrics

# Online Random Forest (river library)
model = tree.HoeffdingAdaptiveTreeClassifier(
    grace_period=100,
    split_confidence=1e-5
)

# –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ
for x, y in zip(X_stream, y_stream):
    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
    y_pred = model.predict_one(x)
    
    # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
    model.learn_one(x, y)
    
    # –ú–µ—Ç—Ä–∏–∫–∏
    if y_pred is not None:
        metric.update(y, y_pred)

print(f"Running accuracy: {metric.get()}")</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 12. Rule-based —Å–∏—Å—Ç–µ–º–∞</h2>
<pre><code># –ö–æ–º–±–∏–Ω–∞—Ü–∏—è ML + –ø—Ä–∞–≤–∏–ª–∞
def fraud_detection_system(transaction, ml_model):
    # –ñ–µ—Å—Ç–∫–∏–µ –ø—Ä–∞–≤–∏–ª–∞ (–≤—Å–µ–≥–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å)
    if transaction["amount"] > 10000 and transaction["country"] == "risky":
        return "BLOCK", 1.0, "Rule: High amount in risky country"
    
    if transaction["velocity"] < 60:  # < 1 –º–∏–Ω—É—Ç—ã –º–µ–∂–¥—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏
        return "BLOCK", 1.0, "Rule: Too fast transactions"
    
    # ML –º–æ–¥–µ–ª—å
    features = extract_features(transaction)
    fraud_prob = ml_model.predict_proba([features])[0, 1]
    
    # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ
    if fraud_prob > 0.9:
        return "BLOCK", fraud_prob, "ML: High fraud probability"
    elif fraud_prob > 0.7:
        return "REVIEW", fraud_prob, "ML: Medium fraud probability"
    else:
        return "APPROVE", fraud_prob, "ML: Low fraud probability"</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 13. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥</h2>
<pre><code># Tracking model performance
import wandb

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
wandb.init(project="fraud-detection")

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –º–µ—Ç—Ä–∏–∫
wandb.log({
    "precision": precision,
    "recall": recall,
    "f1": f1,
    "roc_auc": roc_auc,
    "pr_auc": pr_auc,
    "false_positives": fp,
    "false_negatives": fn,
    "fraud_rate": y_test.mean(),
    "detection_rate": tp / (tp + fn)
})

# –ê–ª–µ—Ä—Ç—ã –ø—Ä–∏ –¥–µ–≥—Ä–∞–¥–∞—Ü–∏–∏
if pr_auc < 0.85:
    send_alert("Model performance degraded!")
    retrain_model()</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 14. Feature Store</h2>
<pre><code># Feast –¥–ª—è feature management
from feast import FeatureStore

store = FeatureStore(repo_path=".")

# –ü–æ–ª—É—á–µ–Ω–∏–µ features –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
entity_rows = [{
    "user_id": transaction["user_id"],
    "event_timestamp": transaction["timestamp"]
}]

features = store.get_online_features(
    features=[
        "user_features:count_24h",
        "user_features:sum_24h",
        "user_features:avg_amount"
    ],
    entity_rows=entity_rows
).to_dict()

# Real-time feature computation + historical features</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 15. Best Practices</h2>
<ul><li>[ ] –†–∞–±–æ—Ç–∞—Ç—å —Å –¥–∏—Å–±–∞–ª–∞–Ω—Å–æ–º (SMOTE, class weights)</li><li>[ ] –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ (PR AUC > ROC AUC)</li><li>[ ] –ü–æ–¥–±–∏—Ä–∞—Ç—å threshold –ø–æ–¥ –±–∏–∑–Ω–µ—Å-—Ü–µ–ª–∏</li><li>[ ] –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å ML + rules</li><li>[ ] –û–±–µ—Å–ø–µ—á–∏—Ç—å –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å (SHAP)</li><li>[ ] Real-time inference (<100ms)</li><li>[ ] Continuous monitoring –∏ retraining</li><li>[ ] A/B —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –º–æ–¥–µ–ª–µ–π</li></ul>
  </div>

  <div class="block">
    <h2>üî∑ 16. –ß–µ–∫-–ª–∏—Å—Ç</h2>
<ul><li>[ ] Features —Å–æ–∑–¥–∞–Ω—ã (temporal, aggregated, deviations)</li><li>[ ] –î–∏—Å–±–∞–ª–∞–Ω—Å –æ–±—Ä–∞–±–æ—Ç–∞–Ω</li><li>[ ] –ú–æ–¥–µ–ª—å –æ–±—É—á–µ–Ω–∞ (RF/XGB/LGB)</li><li>[ ] Threshold –ø–æ–¥–æ–±—Ä–∞–Ω</li><li>[ ] –ú–µ—Ç—Ä–∏–∫–∏ –≤—ã—á–∏—Å–ª–µ–Ω—ã (Precision/Recall/PR AUC)</li><li>[ ] Explainability –¥–æ–±–∞–≤–ª–µ–Ω–∞</li><li>[ ] Real-time API –≥–æ—Ç–æ–≤</li><li>[ ] –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –Ω–∞—Å—Ç—Ä–æ–µ–Ω</li></ul><blockquote>¬´–í fraud detection false positive —Å—Ç–æ–∏—Ç –ø–æ—Ç–µ—Ä—è–Ω–Ω–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞, false negative ‚Äî –ø–æ—Ç–µ—Ä—è–Ω–Ω—ã—Ö –¥–µ–Ω–µ–≥. –ó–∞–¥–∞—á–∞ ‚Äî –Ω–∞–π—Ç–∏ –±–∞–ª–∞–Ω—Å, –∫–æ—Ç–æ—Ä—ã–π –º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ—Ç —Å—É–º–º–∞—Ä–Ω—ã–µ –ø–æ—Ç–µ—Ä–∏ –±–∏–∑–Ω–µ—Å–∞¬ª.</blockquote>
  </div>

</div>

</div>
</body>
</html>
