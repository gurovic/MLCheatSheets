<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Message Passing Networks Cheatsheet ‚Äî 3 –∫–æ–ª–æ–Ω–∫–∏</title>
  <style>
    @media screen { body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; color: #333; background: #fafcff; padding: 10px; } }
    @media print { body { background: white; padding: 0; } @page { size: A4 landscape; margin: 10mm; } }
    .container { column-count: 3; column-gap: 20px; max-width: 100%; }
    .block { break-inside: avoid; margin-bottom: 1.2em; padding: 12px; background: white; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
    h1 { font-size: 1.6em; font-weight: 700; color: #1a5fb4; text-align: center; margin: 0 0 8px; column-span: all; }
    .subtitle { text-align: center; color: #666; font-size: 0.9em; margin-bottom: 12px; column-span: all; }
    h2 { font-size: 1.15em; font-weight: 700; color: #1a5fb4; margin: 0 0 8px; padding-bottom: 4px; border-bottom: 1px solid #e0e7ff; }
    p, ul, ol { font-size: 0.92em; margin: 0.6em 0; }
    ul, ol { padding-left: 18px; }
    li { margin-bottom: 4px; }
    code { font-family: 'Consolas', 'Courier New', monospace; background-color: #f0f4ff; padding: 1px 4px; border-radius: 3px; font-size: 0.88em; }
    pre { background-color: #f0f4ff; padding: 8px; border-radius: 4px; overflow-x: auto; font-size: 0.84em; margin: 6px 0; }
    pre code { padding: 0; background: none; white-space: pre-wrap; }
    table { width: 100%; border-collapse: collapse; font-size: 0.82em; margin: 6px 0; }
    th { background-color: #e6f0ff; text-align: left; padding: 4px 6px; font-weight: 600; }
    td { padding: 4px 6px; border-bottom: 1px solid #f0f4ff; }
    tr:nth-child(even) { background-color: #f8fbff; }
    .good-vs-bad { display: flex; flex-direction: column; gap: 8px; }
    .good-vs-bad div { flex: 1; padding: 6px 8px; border-radius: 4px; }
    .good { background-color: #f0f9f4; border-left: 3px solid #2e8b57; }
    .bad { background-color: #fdf0f2; border-left: 3px solid #d32f2f; }
    .good h3, .bad h3 { margin: 0 0 4px; font-size: 1em; font-weight: 700; }
    .good ul, .bad ul { padding-left: 20px; margin: 0; }
    .good li::before { content: "‚úÖ "; font-weight: bold; }
    .bad li::before { content: "‚ùå "; font-weight: bold; }
    blockquote { font-style: italic; margin: 8px 0; padding: 6px 10px; background: #f8fbff; border-left: 2px solid #1a5fb4; font-size: 0.88em; }
    @media print { .container { column-gap: 12px; } .block { box-shadow: none; } code, pre, table { font-size: 0.78em; } h1 { font-size: 1.4em; } h2 { font-size: 1em; } }
  </style>
</head>
<body>
<div class="container">
  <h1>üì® Message Passing Networks</h1>
  <div class="subtitle">üìÖ 4 —è–Ω–≤–∞—Ä—è 2026</div>
  <div class="block">
    <h2>üî∑ 1. –°—É—Ç—å MPNN</h2>
    <ul>
      <li><strong>Unified framework</strong>: –æ–±–æ–±—â–µ–Ω–∏–µ –º–Ω–æ–≥–∏—Ö GNN –º–µ—Ç–æ–¥–æ–≤</li>
      <li><strong>Message passing</strong>: —É–∑–ª—ã –æ–±–º–µ–Ω–∏–≤–∞—é—Ç—Å—è "—Å–æ–æ–±—â–µ–Ω–∏—è–º–∏"</li>
      <li><strong>–î–≤–∞ —ç—Ç–∞–ø–∞</strong>: Message + Update</li>
      <li><strong>–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ</strong>: T —Ä–∞—É–Ω–¥–æ–≤ –ø–µ—Ä–µ–¥–∞—á–∏ —Å–æ–æ–±—â–µ–Ω–∏–π</li>
      <li><strong>Readout</strong>: –∞–≥—Ä–µ–≥–∞—Ü–∏—è –¥–ª—è graph-level –∑–∞–¥–∞—á</li>
    </ul>
  <div class="block">
    <h2>üî∑ 2. MPNN Framework</h2>
    <p><strong>–≠—Ç–∞–ø 1: Message passing (T —à–∞–≥–æ–≤):</strong></p>
    <p>m<sub>v</sub><sup>t+1</sup> = Œ£<sub>w‚ààN(v)</sub> M<sub>t</sub>(h<sub>v</sub><sup>t</sup>, h<sub>w</sub><sup>t</sup>, e<sub>vw</sub>)</p>
    <p>h<sub>v</sub><sup>t+1</sup> = U<sub>t</sub>(h<sub>v</sub><sup>t</sup>, m<sub>v</sub><sup>t+1</sup>)</p>
    <p><strong>–≠—Ç–∞–ø 2: Readout:</strong></p>
    <p>≈∑ = R({h<sub>v</sub><sup>T</sup> | v ‚àà G})</p>
    <p>–≥–¥–µ:</p>
    <ul>
      <li>M<sub>t</sub> - message function</li>
      <li>U<sub>t</sub> - update function</li>
      <li>R - readout function</li>
      <li>e<sub>vw</sub> - edge features</li>
    </ul>
  </div>
  <div class="block">
    <h2>üî∑ 3. –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã MPNN</h2>
    <p><strong>Message function M<sub>t</sub>:</strong></p>
    <ul>
      <li>–í—ã—á–∏—Å–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç —Å–æ—Å–µ–¥–∞ w –∫ —É–∑–ª—É v</li>
      <li>–ú–æ–∂–µ—Ç —É—á–∏—Ç—ã–≤–∞—Ç—å edge features</li>
      <li>–ü—Ä–∏–º–µ—Ä—ã: MLP, attention, gating</li>
    </ul>
    <p><strong>Update function U<sub>t</sub>:</strong></p>
    <ul>
      <li>–û–±–Ω–æ–≤–ª—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ —É–∑–ª–∞</li>
      <li>–ü—Ä–∏–º–µ—Ä—ã: GRU, LSTM, MLP</li>
    </ul>
    <p><strong>Readout function R:</strong></p>
    <ul>
      <li>–ê–≥—Ä–µ–≥–∏—Ä—É–µ—Ç —É–∑–ª—ã –¥–ª—è graph-level –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è</li>
      <li>–ü—Ä–∏–º–µ—Ä—ã: sum, mean, max, attention pooling</li>
    </ul>
  </div>
  <div class="block">
    <h2>üî∑ 4. –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è</h2>
    <pre><code>import torch
import torch.nn as nn

class MessagePassingLayer(nn.Module):
    def __init__(self, node_dim, edge_dim, hidden_dim):
        super().__init__()
        # Message function
        self.message_net = nn.Sequential(
            nn.Linear(2*node_dim + edge_dim, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, node_dim)
        )
        # Update function
        self.update_net = nn.GRUCell(node_dim, node_dim)
    
    def forward(self, h, edge_index, edge_attr):
        # h: [N, node_dim]
        # edge_index: [2, E]
        # edge_attr: [E, edge_dim]
        
        row, col = edge_index
        messages = []
        
        # Message computation
        for i in range(edge_index.size(1)):
            src, dst = row[i], col[i]
            msg_input = torch.cat([
                h[src], h[dst], edge_attr[i]
            ])
            msg = self.message_net(msg_input)
            messages.append((dst, msg))
        
        # Aggregate messages
        aggregated = torch.zeros_like(h)
        for dst, msg in messages:
            aggregated[dst] += msg
        
        # Update
        h_new = self.update_net(aggregated, h)
        return h_new</code></pre>
  </div>
  <div class="block">
    <h2>üî∑ 5. PyTorch Geometric MPNN</h2>
    <pre><code>from torch_geometric.nn import MessagePassing
from torch_geometric.utils import add_self_loops, degree

class MPNNConv(MessagePassing):
    def __init__(self, in_channels, out_channels):
        super().__init__(aggr='add')  # aggregation: 'add', 'mean', 'max'
        self.mlp = nn.Sequential(
            nn.Linear(in_channels, out_channels),
            nn.ReLU(),
            nn.Linear(out_channels, out_channels)
        )
    
    def forward(self, x, edge_index):
        # x: [N, in_channels]
        # edge_index: [2, E]
        
        # Add self-loops
        edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(0))
        
        # Start propagating messages
        return self.propagate(edge_index, x=x)
    
    def message(self, x_j):
        # x_j: [E, in_channels] - features of source nodes
        return self.mlp(x_j)
    
    def update(self, aggr_out):
        # aggr_out: [N, out_channels] - aggregated messages
        return aggr_out</code></pre>
  </div>
  <div class="block">
    <h2>üî∑ 6. –†–∞–∑–ª–∏—á–Ω—ã–µ MPNN –≤–∞—Ä–∏–∞–Ω—Ç—ã</h2>
    <table>
      <tr><th>–ú–æ–¥–µ–ª—å</th><th>Message M</th><th>Update U</th></tr>
      <tr><td><strong>GCN</strong></td><td>Wh<sub>w</sub></td><td>œÉ(Œ£m + b)</td></tr>
      <tr><td><strong>GraphSAGE</strong></td><td>h<sub>w</sub></td><td>œÉ(W[h<sub>v</sub>||Œ£m])</td></tr>
      <tr><td><strong>GAT</strong></td><td>Œ±<sub>vw</sub>h<sub>w</sub></td><td>œÉ(Œ£m)</td></tr>
      <tr><td><strong>GIN</strong></td><td>h<sub>w</sub></td><td>MLP((1+Œµ)h<sub>v</sub>+Œ£m)</td></tr>
      <tr><td><strong>MPNN</strong></td><td>NN(h<sub>v</sub>,h<sub>w</sub>,e<sub>vw</sub>)</td><td>GRU(h<sub>v</sub>,Œ£m)</td></tr>
    </table>
  </div>
  <div class="block">
    <h2>üî∑ 7. Edge features –≤ MPNN</h2>
    <pre><code>class MPNNWithEdgeFeatures(MessagePassing):
    def __init__(self, node_dim, edge_dim, hidden_dim):
        super().__init__(aggr='add')
        self.edge_encoder = nn.Linear(edge_dim, hidden_dim)
        self.node_encoder = nn.Linear(node_dim, hidden_dim)
        self.message_mlp = nn.Sequential(
            nn.Linear(2*hidden_dim, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, hidden_dim)
        )
    
    def forward(self, x, edge_index, edge_attr):
        return self.propagate(edge_index, x=x, edge_attr=edge_attr)
    
    def message(self, x_i, x_j, edge_attr):
        # x_i: target node, x_j: source node
        # edge_attr: edge features
        edge_emb = self.edge_encoder(edge_attr)
        x_j_emb = self.node_encoder(x_j)
        msg = self.message_mlp(
            torch.cat([x_j_emb, edge_emb], dim=-1)
        )
        return msg</code></pre>
  </div>
  <div class="block">
    <h2>üî∑ 8. Global graph pooling</h2>
    <pre><code>from torch_geometric.nn import global_add_pool, global_mean_pool

class MPNNGraphClassifier(nn.Module):
    def __init__(self, node_dim, edge_dim, num_classes):
        super().__init__()
        self.conv1 = MPNNConv(node_dim, 64)
        self.conv2 = MPNNConv(64, 64)
        self.conv3 = MPNNConv(64, 64)
        
        # Readout
        self.lin1 = nn.Linear(64, 32)
        self.lin2 = nn.Linear(32, num_classes)
    
    def forward(self, data):
        x, edge_index, batch = data.x, data.edge_index, data.batch
        
        # Message passing
        x = F.relu(self.conv1(x, edge_index))
        x = F.relu(self.conv2(x, edge_index))
        x = F.relu(self.conv3(x, edge_index))
        
        # Pooling (graph-level)
        x = global_add_pool(x, batch)  # or global_mean_pool
        
        # Classification
        x = F.relu(self.lin1(x))
        x = F.dropout(x, p=0.5, training=self.training)
        x = self.lin2(x)
        
        return F.log_softmax(x, dim=1)</code></pre>
  </div>
  <div class="block">
    <h2>üî∑ 9. Attention-based pooling</h2>
    <pre><code>class AttentionPooling(nn.Module):
    def __init__(self, in_channels):
        super().__init__()
        self.attention = nn.Sequential(
            nn.Linear(in_channels, in_channels),
            nn.Tanh(),
            nn.Linear(in_channels, 1)
        )
    
    def forward(self, x, batch):
        # x: [N, in_channels]
        # batch: [N] - graph assignment
        
        # Compute attention scores
        scores = self.attention(x)  # [N, 1]
        
        # Softmax per graph
        scores = scores.squeeze(-1)  # [N]
        attention_weights = torch.zeros_like(scores)
        
        for i in range(batch.max() + 1):
            mask = (batch == i)
            attention_weights[mask] = F.softmax(scores[mask], dim=0)
        
        # Weighted sum
        weighted = x * attention_weights.unsqueeze(-1)
        
        # Aggregate per graph
        return scatter_add(weighted, batch, dim=0)</code></pre>
  </div>
  <div class="block">
    <h2>üî∑ 10. Temporal MPNN</h2>
    <p>–î–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö –≥—Ä–∞—Ñ–æ–≤:</p>
    <pre><code>class TemporalMPNN(nn.Module):
    def __init__(self, node_dim, edge_dim, hidden_dim):
        super().__init__()
        self.mpnn = MPNNConv(node_dim, hidden_dim)
        self.temporal = nn.GRU(hidden_dim, hidden_dim)
    
    def forward(self, graphs_sequence):
        # graphs_sequence: —Å–ø–∏—Å–æ–∫ –≥—Ä–∞—Ñ–æ–≤ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
        hidden = None
        outputs = []
        
        for graph in graphs_sequence:
            # Spatial: MPNN –Ω–∞ —Ç–µ–∫—É—â–µ–º –≥—Ä–∞—Ñ–µ
            x = self.mpnn(graph.x, graph.edge_index)
            
            # Temporal: GRU —á–µ—Ä–µ–∑ –≤—Ä–µ–º—è
            x, hidden = self.temporal(
                x.unsqueeze(0),
                hidden
            )
            outputs.append(x.squeeze(0))
        
        return outputs</code></pre>
  </div>
  <div class="block">
    <h2>üî∑ 11. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Å–æ–≤–µ—Ç—ã</h2>
    <ul>
      <li><strong>–ß–∏—Å–ª–æ —à–∞–≥–æ–≤ T</strong>: 2-5 –æ–±—ã—á–Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ</li>
      <li><strong>Edge features</strong>: –≤–∞–∂–Ω—ã –¥–ª—è –º–æ–ª–µ–∫—É–ª, —Ö–∏–º–∏—á–µ—Å–∫–∏—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π</li>
      <li><strong>Residual connections</strong>: –¥–ª—è –≥–ª—É–±–æ–∫–∏—Ö —Å–µ—Ç–µ–π</li>
      <li><strong>Batch normalization</strong>: –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è</li>
      <li><strong>Virtual node</strong>: –¥–æ–±–∞–≤–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–π —É–∑–µ–ª –¥–ª—è long-range dependencies</li>
      <li><strong>Pre-training</strong>: –Ω–∞ –±–æ–ª—å—à–∏—Ö –≥—Ä–∞—Ñ–æ–≤—ã—Ö –¥–∞—Ç–∞—Å–µ—Ç–∞—Ö</li>
    </ul>
  </div>
  <div class="block">
    <h2>üî∑ 12. Aggregation functions</h2>
    <table>
      <tr><th>–§—É–Ω–∫—Ü–∏—è</th><th>–°–≤–æ–π—Å—Ç–≤–∞</th><th>–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å</th></tr>
      <tr><td><strong>sum</strong></td><td>–ò–Ω–≤–∞—Ä–∏–∞–Ω—Ç–Ω–∞ –∫ –ø–æ—Ä—è–¥–∫—É, –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑–º–µ—Ä–∞</td><td>–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é</td></tr>
      <tr><td><strong>mean</strong></td><td>–ò–Ω–≤–∞—Ä–∏–∞–Ω—Ç–Ω–∞ –∫ –ø–æ—Ä—è–¥–∫—É –∏ —Ä–∞–∑–º–µ—Ä—É</td><td>–†–∞–∑–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –≥—Ä–∞—Ñ–æ–≤</td></tr>
      <tr><td><strong>max</strong></td><td>–ò–Ω–≤–∞—Ä–∏–∞–Ω—Ç–Ω–∞ –∫ –ø–æ—Ä—è–¥–∫—É</td><td>–í–∞–∂–Ω—ã –ø–∏–∫–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è</td></tr>
      <tr><td><strong>attention</strong></td><td>–í–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞</td><td>–†–∞–∑–Ω–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å —É–∑–ª–æ–≤</td></tr>
      <tr><td><strong>lstm</strong></td><td>–ó–∞–≤–∏—Å–∏—Ç –æ—Ç –ø–æ—Ä—è–¥–∫–∞</td><td>–£–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–µ —Å–æ—Å–µ–¥–∏</td></tr>
    </table>
  </div>
  <div class="block">
    <h2>üî∑ 13. –ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è MPNN</h2>
    <table>
      <tr><th>–û–±–ª–∞—Å—Ç—å</th><th>–ó–∞–¥–∞—á–∞</th><th>–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏</th></tr>
      <tr><td><strong>–•–∏–º–∏—è</strong></td><td>–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ –º–æ–ª–µ–∫—É–ª</td><td>Edge features –∫—Ä–∏—Ç–∏—á–Ω—ã</td></tr>
      <tr><td><strong>Drug discovery</strong></td><td>–ú–æ–ª–µ–∫—É–ª—è—Ä–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å</td><td>Graph-level –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è</td></tr>
      <tr><td><strong>–§–∏–∑–∏–∫–∞</strong></td><td>–°–∏–º—É–ª—è—Ü–∏—è —á–∞—Å—Ç–∏—Ü</td><td>–í—Ä–µ–º–µ–Ω–Ω—ã–µ –≥—Ä–∞—Ñ—ã</td></tr>
      <tr><td><strong>NLP</strong></td><td>Dependency parsing</td><td>Directed graphs</td></tr>
      <tr><td><strong>Robotics</strong></td><td>–ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏</td><td>Spatial reasoning</td></tr>
    </table>
  </div>
  <div class="block">
    <h2>üî∑ 14. Expressive power</h2>
    <p><strong>WL-test</strong>: Weisfeiler-Lehman graph isomorphism test</p>
    <ul>
      <li>MPNN –Ω–µ –º–æ—â–Ω–µ–µ WL-test</li>
      <li>–ù–µ –º–æ–∂–µ—Ç —Ä–∞–∑–ª–∏—á–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ non-isomorphic –≥—Ä–∞—Ñ—ã</li>
      <li><strong>–†–µ—à–µ–Ω–∏—è</strong>:
        <ul>
          <li>Higher-order GNN (k-WL)</li>
          <li>Structural features (cycles, subgraphs)</li>
          <li>Random node features</li>
        </ul>
      </li>
    </ul>
    <pre><code># GIN: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω—ã–π MPNN
class GINConv(MessagePassing):
    def __init__(self, in_channels, out_channels, eps=0):
        super().__init__(aggr='add')
        self.eps = nn.Parameter(torch.Tensor([eps]))
        self.mlp = nn.Sequential(
            nn.Linear(in_channels, out_channels),
            nn.ReLU(),
            nn.Linear(out_channels, out_channels)
        )
    
    def forward(self, x, edge_index):
        out = self.propagate(edge_index, x=x)
        return self.mlp((1 + self.eps) * x + out)</code></pre>
  </div>
  <div class="block">
    <h2>üî∑ 15. –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å MPNN</h2>
    <div class="good-vs-bad">
      <div class="good">
        <h3>‚úÖ –•–æ—Ä–æ—à–æ –¥–ª—è</h3>
        <ul>
          <li>–ú–æ–ª–µ–∫—É–ª—è—Ä–Ω—ã–µ –≥—Ä–∞—Ñ—ã (edge features)</li>
          <li>Graph-level –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è</li>
          <li>–ù—É–∂–Ω–∞ –≥–∏–±–∫–æ—Å—Ç—å –≤ –¥–∏–∑–∞–π–Ω–µ</li>
          <li>–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∑–∞–¥–∞—á–∏</li>
          <li>–°–ª–æ–∂–Ω—ã–µ –≥—Ä–∞—Ñ–æ–≤—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã</li>
        </ul>
      </div>
      <div class="bad">
        <h3>‚ùå –û—Å—Ç–æ—Ä–æ–∂–Ω–æ</h3>
        <ul>
          <li>–ü—Ä–æ—Å—Ç—ã–µ –∑–∞–¥–∞—á–∏ (GCN –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ)</li>
          <li>–û—á–µ–Ω—å –±–æ–ª—å—à–∏–µ –≥—Ä–∞—Ñ—ã (–º–µ–¥–ª–µ–Ω–Ω–µ–µ)</li>
          <li>–ù–µ—Ç edge features (–ø—Ä–æ—â–µ –º–µ—Ç–æ–¥—ã)</li>
          <li>Production (—Å–ª–æ–∂–Ω–µ–µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è)</li>
        </ul>
      </div>
    </div>
  </div>
  <div class="block">
    <h2>üî∑ 16. –ß–µ–∫-–ª–∏—Å—Ç</h2>
    <ul>
      <li>[ ] –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å message, update, readout functions</li>
      <li>[ ] –í—ã–±—Ä–∞—Ç—å —á–∏—Å–ª–æ message passing —à–∞–≥–æ–≤ (2-5)</li>
      <li>[ ] –†–µ—à–∏—Ç—å, –Ω—É–∂–Ω—ã –ª–∏ edge features</li>
      <li>[ ] –í—ã–±—Ä–∞—Ç—å aggregation (sum/mean/max/attention)</li>
      <li>[ ] –î–æ–±–∞–≤–∏—Ç—å residual connections –¥–ª—è >3 —Å–ª–æ–µ–≤</li>
      <li>[ ] –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å batch normalization</li>
      <li>[ ] –î–ª—è graph-level: –≤—ã–±—Ä–∞—Ç—å pooling strategy</li>
      <li>[ ] –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ expressive power –µ—Å–ª–∏ –Ω—É–∂–Ω–æ</li>
    </ul>
    <h3>üí° –û–±—ä—è—Å–Ω–µ–Ω–∏–µ –∑–∞–∫–∞–∑—á–∏–∫—É:</h3>
    <blockquote>
      ¬´Message Passing Networks ‚Äî —ç—Ç–æ –æ–±—â–∏–π —Ñ—Ä–µ–π–º–≤–æ—Ä–∫ –¥–ª—è –≥—Ä–∞—Ñ–æ–≤—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π. –£–∑–ª—ã –æ–±–º–µ–Ω–∏–≤–∞—é—Ç—Å—è "—Å–æ–æ–±—â–µ–Ω–∏—è–º–∏" —Å —Å–æ—Å–µ–¥—è–º–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑, –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —Å–æ–±–∏—Ä–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é —Å–æ –≤—Å–µ–≥–æ –≥—Ä–∞—Ñ–∞. –ö–∞–∫ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π –≤ —Å–µ—Ç–∏: –∫–∞–∂–¥—ã–π —É–∑–µ–ª –ø–æ–ª—É—á–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ—Ç –¥—Ä—É–∑–µ–π, –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å–≤–æ–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ, –∏ –ø–µ—Ä–µ–¥–∞–µ—Ç –¥–∞–ª—å—à–µ¬ª.
    </blockquote>
  </div>
</div>
</div>
</body>
</html>