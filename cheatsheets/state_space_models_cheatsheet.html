<!DOCTYPE html>
<html lang="ru">
<head><meta charset="UTF-8"><title>State Space Models ‚Äî 3 –∫–æ–ª–æ–Ω–∫–∏</title>
<style>@media screen{body{font-family:Arial,sans-serif;color:#333;background:#fafcff;padding:10px}}.container{column-count:3;column-gap:20px;max-width:100%}.block{break-inside:avoid;margin-bottom:1.2em;padding:12px;background:white;border-radius:6px;box-shadow:0 1px 3px rgba(0,0,0,0.05)}h1{font-size:1.6em;font-weight:700;color:#1a5fb4;text-align:center;margin:0 0 8px;column-span:all}.subtitle{text-align:center;color:#666;font-size:0.9em;margin-bottom:12px;column-span:all}h2{font-size:1.15em;font-weight:700;color:#1a5fb4;margin:0 0 8px;padding-bottom:4px;border-bottom:1px solid #e0e7ff}p,ul,ol{font-size:0.92em;margin:0.6em 0}ul,ol{padding-left:18px}li{margin-bottom:4px}code{font-family:Consolas,monospace;background-color:#f0f4ff;padding:1px 4px;border-radius:3px;font-size:0.88em}pre{background-color:#f0f4ff;padding:8px;border-radius:4px;overflow-x:auto;font-size:0.84em;margin:6px 0}pre code{padding:0;background:none;white-space:pre-wrap}table{width:100%;border-collapse:collapse;font-size:0.82em;margin:6px 0}th{background-color:#e6f0ff;text-align:left;padding:4px 6px;font-weight:600}td{padding:4px 6px;border-bottom:1px solid #f0f4ff}tr:nth-child(even){background-color:#f8fbff}blockquote{font-style:italic;margin:8px 0;padding:6px 10px;background:#f8fbff;border-left:2px solid #1a5fb4;font-size:0.88em}</style></head>
<body><div class="container"><h1>üîÑ State Space Models</h1>
<div class="subtitle">üìÖ 4 —è–Ω–≤–∞—Ä—è 2026</div>

<div class="block"><h2>üî∑ 1. –°—É—Ç—å</h2><ul>
<li><strong>–¶–µ–ª—å</strong>: –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö —Å–∏—Å—Ç–µ–º</li>
<li><strong>–ò–¥–µ—è</strong>: —Å–∫—Ä—ã—Ç–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ + –Ω–∞–±–ª—é–¥–µ–Ω–∏—è</li>
<li><strong>–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ</strong>: –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä—è–¥—ã, tracking, control</li>
<li><strong>–°–æ—Å—Ç–æ—è–Ω–∏–µ</strong>: –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ, –Ω–µ–Ω–∞–±–ª—é–¥–∞–µ–º–æ–µ</li>
<li><strong>–ù–∞–±–ª—é–¥–µ–Ω–∏–µ</strong>: —Ç–æ, —á—Ç–æ –º—ã –≤–∏–¥–∏–º</li></ul></div>

<div class="block"><h2>üî∑ 2. –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å</h2>
<p><strong>State equation (—ç–≤–æ–ª—é—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è)</strong>:</p>
<pre><code>x_t = A*x_{t-1} + B*u_t + w_t
–≥–¥–µ:
- x_t: —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ –º–æ–º–µ–Ω—Ç t
- A: –º–∞—Ç—Ä–∏—Ü–∞ –ø–µ—Ä–µ—Ö–æ–¥–∞
- u_t: —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
- w_t: —à—É–º –ø—Ä–æ—Ü–µ—Å—Å–∞ (N(0, Q))</code></pre>
<p><strong>Observation equation (–∏–∑–º–µ—Ä–µ–Ω–∏—è)</strong>:</p>
<pre><code>y_t = C*x_t + v_t
–≥–¥–µ:
- y_t: –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ
- C: –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞–±–ª—é–¥–µ–Ω–∏—è
- v_t: —à—É–º –∏–∑–º–µ—Ä–µ–Ω–∏–π (N(0, R))</code></pre></div>

<div class="block"><h2>üî∑ 3. Kalman Filter</h2>
<p><strong>–û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä</strong> –¥–ª—è –ª–∏–Ω–µ–π–Ω—ã—Ö SSM —Å –≥–∞—É—Å—Å–æ–≤—Å–∫–∏–º —à—É–º–æ–º</p>
<p><strong>Predict step</strong>:</p>
<pre><code>xÃÇ_t|t-1 = A * xÃÇ_t-1|t-1 + B * u_t
P_t|t-1 = A * P_t-1|t-1 * A^T + Q</code></pre>
<p><strong>Update step</strong>:</p>
<pre><code>K_t = P_t|t-1 * C^T * (C*P_t|t-1*C^T + R)^{-1}
xÃÇ_t|t = xÃÇ_t|t-1 + K_t * (y_t - C*xÃÇ_t|t-1)
P_t|t = (I - K_t*C) * P_t|t-1</code></pre></div>

<div class="block"><h2>üî∑ 4. –ö–æ–¥ Kalman Filter</h2>
<pre><code>import numpy as np

class KalmanFilter:
    def __init__(self, A, C, Q, R, x0, P0):
        self.A = A  # State transition
        self.C = C  # Observation
        self.Q = Q  # Process noise covariance
        self.R = R  # Measurement noise covariance
        self.x = x0  # Initial state
        self.P = P0  # Initial covariance
        
    def predict(self, u=None):
        # Predict state
        self.x = self.A @ self.x
        if u is not None:
            self.x += self.B @ u
        # Predict covariance
        self.P = self.A @ self.P @ self.A.T + self.Q
        return self.x
    
    def update(self, y):
        # Kalman gain
        S = self.C @ self.P @ self.C.T + self.R
        K = self.P @ self.C.T @ np.linalg.inv(S)
        
        # Update state
        innovation = y - self.C @ self.x
        self.x = self.x + K @ innovation
        
        # Update covariance
        self.P = (np.eye(len(self.x)) - K @ self.C) @ self.P
        return self.x</code></pre></div>

<div class="block"><h2>üî∑ 5. –ü—Ä–∏–º–µ—Ä: Tracking –æ–±—ä–µ–∫—Ç–∞</h2>
<pre><code># –°–æ—Å—Ç–æ—è–Ω–∏–µ: [x, y, vx, vy]
# –ù–∞–±–ª—é–¥–µ–Ω–∏–µ: [x, y]

dt = 0.1  # time step

# State transition (constant velocity)
A = np.array([
    [1, 0, dt, 0],
    [0, 1, 0, dt],
    [0, 0, 1, 0],
    [0, 0, 0, 1]
])

# Observation (—Ç–æ–ª—å–∫–æ –ø–æ–∑–∏—Ü–∏—è)
C = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0]
])

# Noise covariances
Q = np.eye(4) * 0.01  # process noise
R = np.eye(2) * 1.0   # measurement noise

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
x0 = np.array([0, 0, 0, 0])
P0 = np.eye(4) * 10

kf = KalmanFilter(A, C, Q, R, x0, P0)

# Tracking
for observation in measurements:
    kf.predict()
    state = kf.update(observation)
    print(f"Position: {state[:2]}, Velocity: {state[2:]}")</code></pre></div>

<div class="block"><h2>üî∑ 6. Extended Kalman Filter (EKF)</h2>
<p><strong>–î–ª—è –Ω–µ–ª–∏–Ω–µ–π–Ω—ã—Ö —Å–∏—Å—Ç–µ–º</strong>:</p>
<pre><code>x_t = f(x_{t-1}, u_t) + w_t
y_t = h(x_t) + v_t

# –õ–∏–Ω–µ–∞—Ä–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ Jacobian
F_t = ‚àÇf/‚àÇx |_{x=xÃÇ_{t-1}}
H_t = ‚àÇh/‚àÇx |_{x=xÃÇ_t}</code></pre>
<pre><code>class ExtendedKalmanFilter:
    def __init__(self, f, h, F_jacobian, H_jacobian, Q, R, x0, P0):
        self.f = f  # nonlinear state function
        self.h = h  # nonlinear observation function
        self.F_jac = F_jacobian
        self.H_jac = H_jacobian
        self.Q = Q
        self.R = R
        self.x = x0
        self.P = P0
    
    def predict(self):
        # Nonlinear predict
        self.x = self.f(self.x)
        F = self.F_jac(self.x)
        self.P = F @ self.P @ F.T + self.Q
    
    def update(self, y):
        H = self.H_jac(self.x)
        y_pred = self.h(self.x)
        
        S = H @ self.P @ H.T + self.R
        K = self.P @ H.T @ np.linalg.inv(S)
        
        self.x = self.x + K @ (y - y_pred)
        self.P = (np.eye(len(self.x)) - K @ H) @ self.P</code></pre></div>

<div class="block"><h2>üî∑ 7. Unscented Kalman Filter (UKF)</h2>
<p><strong>–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ EKF</strong>: –±–µ–∑ —è–∫–æ–±–∏–∞–Ω–æ–≤</p>
<p><strong>–ò–¥–µ—è</strong>: sigma points –≤–º–µ—Å—Ç–æ –ª–∏–Ω–µ–∞—Ä–∏–∑–∞—Ü–∏–∏</p>
<pre><code>from filterpy.kalman import UnscentedKalmanFilter as UKF
from filterpy.kalman import MerweScaledSigmaPoints

# Sigma points
points = MerweScaledSigmaPoints(n=4, alpha=0.1, beta=2., kappa=-1)

def fx(x, dt):
    """State transition function"""
    return np.array([
        x[0] + x[2]*dt,
        x[1] + x[3]*dt,
        x[2],
        x[3]
    ])

def hx(x):
    """Observation function"""
    return np.array([x[0], x[1]])

ukf = UKF(dim_x=4, dim_z=2, dt=0.1, 
          fx=fx, hx=hx, points=points)
ukf.Q = Q
ukf.R = R

# Use
for z in measurements:
    ukf.predict()
    ukf.update(z)</code></pre></div>

<div class="block"><h2>üî∑ 8. Particle Filter</h2>
<p><strong>–î–ª—è –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã—Ö —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π</strong></p>
<pre><code># Monte Carlo approach
class ParticleFilter:
    def __init__(self, n_particles, f, h):
        self.n = n_particles
        self.particles = np.random.randn(n_particles, 4)
        self.weights = np.ones(n_particles) / n_particles
        self.f = f  # state transition
        self.h = h  # observation
    
    def predict(self):
        # Move particles
        for i in range(self.n):
            self.particles[i] = self.f(self.particles[i])
            self.particles[i] += np.random.randn(4) * 0.1
    
    def update(self, y):
        # Weight particles by likelihood
        for i in range(self.n):
            y_pred = self.h(self.particles[i])
            error = y - y_pred
            self.weights[i] *= np.exp(-0.5 * error @ error)
        
        # Normalize
        self.weights /= self.weights.sum()
        
        # Resample if needed
        if 1./np.sum(self.weights**2) < self.n/2:
            self.resample()
    
    def resample(self):
        indices = np.random.choice(self.n, self.n, p=self.weights)
        self.particles = self.particles[indices]
        self.weights = np.ones(self.n) / self.n
    
    def estimate(self):
        return np.average(self.particles, weights=self.weights, axis=0)</code></pre></div>

<div class="block"><h2>üî∑ 9. SSM –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ä—è–¥–æ–≤</h2>
<p><strong>Structural Time Series Models</strong>:</p>
<pre><code>import statsmodels.api as sm

# Trend + Seasonal + Irregular
model = sm.tsa.UnobservedComponents(
    y,
    level='local linear trend',
    seasonal=12,
    cycle=True
)

result = model.fit()

# Forecast
forecast = result.forecast(steps=10)

# Smoothed state
smoothed_state = result.smoothed_state</code></pre></div>

<div class="block"><h2>üî∑ 10. –ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è</h2><ul>
<li><strong>Navigation</strong>: GPS + IMU fusion</li>
<li><strong>Robotics</strong>: SLAM, –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è</li>
<li><strong>Finance</strong>: –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏</li>
<li><strong>Economics</strong>: –º–∞–∫—Ä–æ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã</li>
<li><strong>Meteorology</strong>: –ø—Ä–æ–≥–Ω–æ–∑ –ø–æ–≥–æ–¥—ã</li>
<li><strong>Control</strong>: –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</li>
<li><strong>Signal processing</strong>: —à—É–º–æ–ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ</li></ul></div>

<div class="block"><h2>üî∑ 11. Smoother vs Filter</h2>
<table><tr><th>–¢–∏–ø</th><th>–û–ø–∏—Å–∞–Ω–∏–µ</th><th>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ</th></tr>
<tr><td>Filter</td><td>xÃÇ_t|t (—Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ)</td><td>Real-time</td></tr>
<tr><td>Smoother</td><td>xÃÇ_t|T (—Å –±—É–¥—É—â–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏)</td><td>Post-processing</td></tr>
<tr><td>Predictor</td><td>xÃÇ_{t+k}|t (–ø—Ä–æ–≥–Ω–æ–∑)</td><td>Forecasting</td></tr></table>
<pre><code># Rauch-Tung-Striebel Smoother
def rts_smoother(filtered_states, filtered_covs, A):
    n = len(filtered_states)
    smoothed = filtered_states.copy()
    smoothed_covs = filtered_covs.copy()
    
    for t in range(n-2, -1, -1):
        P_pred = A @ filtered_covs[t] @ A.T + Q
        J = filtered_covs[t] @ A.T @ np.linalg.inv(P_pred)
        
        smoothed[t] = filtered_states[t] + J @ (
            smoothed[t+1] - A @ filtered_states[t]
        )
        smoothed_covs[t] = filtered_covs[t] + J @ (
            smoothed_covs[t+1] - P_pred
        ) @ J.T
    
    return smoothed, smoothed_covs</code></pre></div>

<div class="block"><h2>üî∑ 12. –û—Ü–µ–Ω–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</h2>
<p><strong>EM Algorithm –¥–ª—è SSM</strong>:</p>
<pre><code># Expectation-Maximization
def em_for_ssm(y, n_iter=100):
    # Initialize parameters
    A, C, Q, R = initialize_params()
    
    for _ in range(n_iter):
        # E-step: Kalman Smoother
        states, covs = kalman_smoother(y, A, C, Q, R)
        
        # M-step: Update parameters
        A = update_A(states, covs)
        C = update_C(y, states)
        Q = update_Q(states, covs, A)
        R = update_R(y, states, C)
    
    return A, C, Q, R</code></pre></div>

<div class="block"><h2>üî∑ 13. –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–≤</h2>
<table><tr><th>–ú–µ—Ç–æ–¥</th><th>–õ–∏–Ω–µ–π–Ω–æ—Å—Ç—å</th><th>Noise</th><th>–°–ª–æ–∂–Ω–æ—Å—Ç—å</th></tr>
<tr><td>Kalman Filter</td><td>–õ–∏–Ω–µ–π–Ω—ã–π</td><td>Gaussian</td><td>O(n¬≥)</td></tr>
<tr><td>EKF</td><td>–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π</td><td>Gaussian</td><td>O(n¬≥)</td></tr>
<tr><td>UKF</td><td>–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π</td><td>Gaussian</td><td>O(n¬≥)</td></tr>
<tr><td>Particle Filter</td><td>–õ—é–±–æ–π</td><td>–õ—é–±–æ–π</td><td>O(N_particles)</td></tr></table></div>

<div class="block"><h2>üî∑ 14. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Å–æ–≤–µ—Ç—ã</h2><ul>
<li><strong>–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è</strong>: P0 –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–æ–ª—å—à–∞—è</li>
<li><strong>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ Q –∏ R</strong>: balance process vs measurement trust</li>
<li><strong>–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏</strong>: trace(P) –¥–æ–ª–∂–µ–Ω —É–±—ã–≤–∞—Ç—å</li>
<li><strong>Innovation</strong>: y - C*xÃÇ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏</li>
<li><strong>Numerical stability</strong>: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Joseph form –¥–ª—è P</li>
<li><strong>Adaptive filtering</strong>: –ø–æ–¥—Å—Ç—Ä–æ–π–∫–∞ Q, R –æ–Ω–ª–∞–π–Ω</li></ul></div>

<div class="block"><h2>üî∑ 15. –ß–µ–∫-–ª–∏—Å—Ç</h2><ul>
<li>[ ] –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ x_t</li>
<li>[ ] –í—ã–±—Ä–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—ã A, C</li>
<li>[ ] –û—Ü–µ–Ω–∏—Ç—å —à—É–º—ã Q, R</li>
<li>[ ] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å x0, P0</li>
<li>[ ] –í—ã–±—Ä–∞—Ç—å —Ñ–∏–ª—å—Ç—Ä (KF/EKF/UKF/PF)</li>
<li>[ ] –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å predict + update</li>
<li>[ ] –í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ —Å–∏–Ω—Ç–µ—Ç–∏–∫–µ</li>
<li>[ ] –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö</li>
<li>[ ] –ú–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å innovation</li></ul>
<blockquote>¬´State Space Models ‚Äî –º–æ—â–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏. 
–û–Ω–∏ –ø–æ–∑–≤–æ–ª—è—é—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å —Å–∫—Ä—ã—Ç—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è, –¥–µ–ª–∞—Ç—å –ø—Ä–æ–≥–Ω–æ–∑—ã –∏ –æ—Ü–µ–Ω–∏–≤–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã 
–∏–∑ –∑–∞—à—É–º–ª–µ–Ω–Ω—ã—Ö –Ω–∞–±–ª—é–¥–µ–Ω–∏–π. Kalman Filter ‚Äî —ç—Ç–æ –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä –¥–ª—è –ª–∏–Ω–µ–π–Ω—ã—Ö —Å–∏—Å—Ç–µ–º, 
–∞ –µ–≥–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è (EKF, UKF, Particle Filter) —Ä–∞–±–æ—Ç–∞—é—Ç —Å –Ω–µ–ª–∏–Ω–µ–π–Ω—ã–º–∏ —Å–ª—É—á–∞—è–º–∏¬ª.</blockquote></div>

</div></body></html>
