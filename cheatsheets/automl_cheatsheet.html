<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>AutoML: –ü–æ–ª–Ω—ã–π –æ–±–∑–æ—Ä Cheatsheet ‚Äî 3 –∫–æ–ª–æ–Ω–∫–∏</title>
  <style>
    @media screen {
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
        color: #333;
        background: #fafcff;
        padding: 10px;
      }
    }
    @media print {
      body {
        background: white;
        padding: 0;
      }
      @page {
        size: A4 landscape;
        margin: 10mm;
      }
    }

    .container {
      column-count: 3;
      column-gap: 20px;
      max-width: 100%;
    }

    .block {
      break-inside: avoid;
      margin-bottom: 1.2em;
      padding: 12px;
      background: white;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }

    h1 {
      font-size: 1.6em;
      font-weight: 700;
      color: #1a5fb4;
      text-align: center;
      margin: 0 0 8px;
      column-span: all;
    }

    .subtitle {
      text-align: center;
      color: #666;
      font-size: 0.9em;
      margin-bottom: 12px;
      column-span: all;
    }

    h2 {
      font-size: 1.15em;
      font-weight: 700;
      color: #1a5fb4;
      margin: 0 0 8px;
      padding-bottom: 4px;
      border-bottom: 1px solid #e0e7ff;
    }

    p, ul, ol {
      font-size: 0.92em;
      margin: 0.6em 0;
    }

    ul, ol {
      padding-left: 18px;
    }

    li {
      margin-bottom: 4px;
    }

    code {
      font-family: 'Consolas', 'Courier New', monospace;
      background-color: #f0f4ff;
      padding: 1px 4px;
      border-radius: 3px;
      font-size: 0.88em;
    }

    pre {
      background-color: #f0f4ff;
      padding: 8px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 0.84em;
      margin: 6px 0;
    }

    pre code {
      padding: 0;
      background: none;
      white-space: pre-wrap;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.82em;
      margin: 6px 0;
    }

    th {
      background-color: #e6f0ff;
      text-align: left;
      padding: 4px 6px;
      font-weight: 600;
    }

    td {
      padding: 4px 6px;
      border-bottom: 1px solid #f0f4ff;
    }

    tr:nth-child(even) {
      background-color: #f8fbff;
    }

    .good-vs-bad {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .good-vs-bad div {
      flex: 1;
      padding: 6px 8px;
      border-radius: 4px;
    }

    .good {
      background-color: #f0f9f4;
      border-left: 3px solid #2e8b57;
    }

    .bad {
      background-color: #fdf0f2;
      border-left: 3px solid #d32f2f;
    }

    .good h3, .bad h3 {
      margin: 0 0 4px;
      font-size: 1em;
      font-weight: 700;
    }

    .good ul, .bad ul {
      padding-left: 20px;
      margin: 0;
    }

    .good li::before { content: "‚úÖ "; font-weight: bold; }
    .bad li::before { content: "‚ùå "; font-weight: bold; }

    blockquote {
      font-style: italic;
      margin: 8px 0;
      padding: 6px 10px;
      background: #f8fbff;
      border-left: 2px solid #1a5fb4;
      font-size: 0.88em;
    }

    @media print {
      .container { column-gap: 12px; }
      .block { box-shadow: none; }
      code, pre, table { font-size: 0.78em; }
      h1 { font-size: 1.4em; }
      h2 { font-size: 1em; }
    }
  </style>
</head>
<body>

<div class="container">

  <h1>ü§ñ AutoML: –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è Cheatsheet</h1>
  <div class="subtitle">–ü–æ–ª–Ω—ã–π –æ–±–∑–æ—Ä ‚Ä¢ –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–∏ ‚Ä¢ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π —Ñ–æ–∫—É—Å<br>üìÖ –Ø–Ω–≤–∞—Ä—å 2026</div>

  <div class="block">
    <h2>üî∑ 1. –ß—Ç–æ —Ç–∞–∫–æ–µ AutoML?</h2>
    <ul>
      <li><strong>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ</strong>: –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è</li>
      <li><strong>–¶–µ–ª—å</strong>: —Å–Ω–∏–∑–∏—Ç—å –±–∞—Ä—å–µ—Ä –≤—Ö–æ–¥–∞ –≤ ML, —É—Å–∫–æ—Ä–∏—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É</li>
      <li><strong>–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä—É–µ—Ç</strong>: –≤—ã–±–æ—Ä –º–æ–¥–µ–ª–µ–π, –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä—ã, feature engineering</li>
      <li><strong>–î–ª—è –∫–æ–≥–æ</strong>: data scientists –∏ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏</li>
      <li><strong>–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞</strong>: —ç–∫–æ–Ω–æ–º–∏—è –≤—Ä–µ–º–µ–Ω–∏, –±–∞–∑–æ–≤—ã–µ —Ä–µ—à–µ–Ω–∏—è, —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—ã</li>
    </ul>
  </div>

  <div class="block">
    <h2>üî∑ 2. –ß—Ç–æ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä—É–µ—Ç—Å—è?</h2>
    <table>
      <tr><th>–≠—Ç–∞–ø</th><th>–û–ø–∏—Å–∞–Ω–∏–µ</th></tr>
      <tr><td><strong>–ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞</strong></td><td>–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–ø—É—Å–∫–æ–≤, –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π</td></tr>
      <tr><td><strong>Feature Engineering</strong></td><td>–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤</td></tr>
      <tr><td><strong>–í—ã–±–æ—Ä –º–æ–¥–µ–ª–∏</strong></td><td>–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–±–æ—Ä –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤</td></tr>
      <tr><td><strong>–ü–æ–¥–±–æ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</strong></td><td>–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</td></tr>
      <tr><td><strong>–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞</strong></td><td>–ü–æ–∏—Å–∫ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π (NAS)</td></tr>
      <tr><td><strong>–ê–Ω—Å–∞–º–±–ª–∏</strong></td><td>–°–æ–∑–¥–∞–Ω–∏–µ –∞–Ω—Å–∞–º–±–ª–µ–π –º–æ–¥–µ–ª–µ–π</td></tr>
      <tr><td><strong>–í–∞–ª–∏–¥–∞—Ü–∏—è</strong></td><td>–ö—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è –∏ –æ—Ü–µ–Ω–∫–∞</td></tr>
    </table>
  </div>

  <div class="block">
    <h2>üî∑ 3. Auto-sklearn</h2>
    <p>–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ scikit-learn:</p>
    <pre><code># –£—Å—Ç–∞–Ω–æ–≤–∫–∞
# pip install auto-sklearn

from autosklearn.classification import AutoSklearnClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# AutoML –º–æ–¥–µ–ª—å
automl = AutoSklearnClassifier(
    time_left_for_this_task=3600,  # 1 —á–∞—Å
    per_run_time_limit=300,         # 5 –º–∏–Ω—É—Ç –Ω–∞ –º–æ–¥–µ–ª—å
    n_jobs=-1,
    memory_limit=8192,              # –ú–ë
    ensemble_size=50
)

# –û–±—É—á–µ–Ω–∏–µ
automl.fit(X_train, y_train)

# –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
y_pred = automl.predict(X_test)
print(f"Accuracy: {accuracy_score(y_test, y_pred):.3f}")

# –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
print(automl.sprint_statistics())
print(automl.show_models())</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 4. TPOT (Tree-based Pipeline Optimization)</h2>
    <pre><code># –£—Å—Ç–∞–Ω–æ–≤–∫–∞
# pip install tpot

from tpot import TPOTClassifier
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# TPOT –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≥–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
tpot = TPOTClassifier(
    generations=5,           # –ø–æ–∫–æ–ª–µ–Ω–∏—è —ç–≤–æ–ª—é—Ü–∏–∏
    population_size=50,      # —Ä–∞–∑–º–µ—Ä –ø–æ–ø—É–ª—è—Ü–∏–∏
    cv=5,                    # –∫—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è
    random_state=42,
    verbosity=2,
    n_jobs=-1,
    max_time_mins=60,        # –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
    max_eval_time_mins=5     # –≤—Ä–µ–º—è –Ω–∞ –æ–¥–Ω—É –º–æ–¥–µ–ª—å
)

# –û–±—É—á–µ–Ω–∏–µ
tpot.fit(X_train, y_train)

# –û—Ü–µ–Ω–∫–∞
print(f"Score: {tpot.score(X_test, y_test):.3f}")

# –≠–∫—Å–ø–æ—Ä—Ç –ª—É—á—à–µ–≥–æ –ø–∞–π–ø–ª–∞–π–Ω–∞
tpot.export('tpot_pipeline.py')</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 5. H2O AutoML</h2>
    <pre><code># –£—Å—Ç–∞–Ω–æ–≤–∫–∞
# pip install h2o

import h2o
from h2o.automl import H2OAutoML

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è H2O
h2o.init()

# –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ H2O
train = h2o.H2OFrame(df_train)
test = h2o.H2OFrame(df_test)

# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫
x = train.columns
y = 'target'
x.remove(y)

# AutoML
aml = H2OAutoML(
    max_runtime_secs=3600,       # 1 —á–∞—Å
    max_models=20,               # –º–∞–∫—Å. –º–æ–¥–µ–ª–µ–π
    seed=42,
    nfolds=5,                    # –∫—Ä–æ—Å—Å-–≤–∞–ª–∏–¥–∞—Ü–∏—è
    sort_metric='AUC'
)

# –û–±—É—á–µ–Ω–∏–µ
aml.train(x=x, y=y, training_frame=train)

# Leaderboard - —Ä–µ–π—Ç–∏–Ω–≥ –º–æ–¥–µ–ª–µ–π
lb = aml.leaderboard
print(lb)

# –õ—É—á—à–∞—è –º–æ–¥–µ–ª—å
best_model = aml.leader

# –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
preds = best_model.predict(test)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 6. PyCaret</h2>
    <pre><code># –£—Å—Ç–∞–Ω–æ–≤–∫–∞
# pip install pycaret

from pycaret.classification import *

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
clf_setup = setup(
    data=df,
    target='target',
    session_id=42,
    train_size=0.8,
    normalize=True,
    transformation=True,
    ignore_features=['id'],
    silent=True,
    verbose=False
)

# –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π
best_models = compare_models(n_select=3)

# –°–æ–∑–¥–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏
best = create_model('xgboost')

# –¢—é–Ω–∏–Ω–≥
tuned = tune_model(best, n_iter=50)

# –ê–Ω—Å–∞–º–±–ª—å
ensemble = ensemble_model(tuned, method='Bagging')

# –û—Ü–µ–Ω–∫–∞
evaluate_model(ensemble)

# –§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
final = finalize_model(ensemble)
save_model(final, 'my_model')

# –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
predictions = predict_model(final, data=test_df)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 7. MLBox</h2>
    <pre><code># –£—Å—Ç–∞–Ω–æ–≤–∫–∞
# pip install mlbox

from mlbox.preprocessing import Reader, Drift_thresholder
from mlbox.optimisation import Optimiser
from mlbox.prediction import Predictor

# –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
paths = ["train.csv", "test.csv"]
target_name = "target"

rd = Reader(sep=",")
df = rd.train_test_split(paths, target_name)

# –£–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ —Å –¥—Ä–µ–π—Ñ–æ–º
dft = Drift_thresholder()
df = dft.fit_transform(df)

# –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è (AutoML)
opt = Optimiser(
    scoring='accuracy',
    n_folds=5
)

# –ü–æ–∏—Å–∫ –ª—É—á—à–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
best_params = opt.optimise(
    space={'ne__numerical_strategy': {"search": "choice", 
                                       "space": [0, 'mean']}},
    df=df,
    max_evals=40
)

# –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
prd = Predictor()
prd.fit_predict(best_params, df)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 8. AutoKeras (–¥–ª—è –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π)</h2>
    <pre><code># –£—Å—Ç–∞–Ω–æ–≤–∫–∞
# pip install autokeras

import autokeras as ak

# –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
clf = ak.ImageClassifier(
    max_trials=10,          # –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫
    overwrite=True,
    directory='autokeras',
    project_name='image_classification'
)

# –û–±—É—á–µ–Ω–∏–µ
clf.fit(x_train, y_train, epochs=10)

# –û—Ü–µ–Ω–∫–∞
clf.evaluate(x_test, y_test)

# –≠–∫—Å–ø–æ—Ä—Ç –º–æ–¥–µ–ª–∏
model = clf.export_model()

# –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞
text_clf = ak.TextClassifier(max_trials=10)
text_clf.fit(x_train, y_train, epochs=10)

# –¢–∞–±–ª–∏—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
structured_clf = ak.StructuredDataClassifier(max_trials=10)
structured_clf.fit(x_train, y_train)

# –†–µ–≥—Ä–µ—Å—Å–∏—è
reg = ak.StructuredDataRegressor(max_trials=10)
reg.fit(x_train, y_train)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 9. Google AutoML Tables</h2>
    <p>–û–±–ª–∞—á–Ω—ã–π —Å–µ—Ä–≤–∏—Å –æ—Ç Google (–ø–ª–∞—Ç–Ω—ã–π):</p>
    <pre><code># –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Google Cloud SDK –∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
# pip install google-cloud-automl

from google.cloud import automl_v1beta1 as automl

# –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞
client = automl.TablesClient(project='project-id', region='us-central1')

# –°–æ–∑–¥–∞–Ω–∏–µ –¥–∞—Ç–∞—Å–µ—Ç–∞
dataset = client.create_dataset(
    dataset_display_name='my_dataset'
)

# –ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö
client.import_data(
    dataset=dataset,
    gcs_input_uris='gs://bucket/data.csv'
)

# –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
model = client.create_model(
    'my_model',
    dataset=dataset,
    train_budget_milli_node_hours=1000,  # ~1 —á–∞—Å
    optimization_objective='MAXIMIZE_AU_ROC'
)

# –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
response = client.predict(
    model_name=model.name,
    inputs={'feature1': value1, 'feature2': value2}
)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 10. –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–≤</h2>
    <table>
      <tr><th>–§—Ä–µ–π–º–≤–æ—Ä–∫</th><th>–ü–ª—é—Å—ã</th><th>–ú–∏–Ω—É—Å—ã</th></tr>
      <tr>
        <td><strong>Auto-sklearn</strong></td>
        <td>–ú–æ—â–Ω—ã–π, –Ω–∞—É—á–Ω—ã–π –ø–æ–¥—Ö–æ–¥</td>
        <td>–ú–µ–¥–ª–µ–Ω–Ω—ã–π, —Å–ª–æ–∂–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞</td>
      </tr>
      <tr>
        <td><strong>TPOT</strong></td>
        <td>–ì–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã, —ç–∫—Å–ø–æ—Ä—Ç –∫–æ–¥–∞</td>
        <td>–î–æ–ª–≥–æ–µ –æ–±—É—á–µ–Ω–∏–µ</td>
      </tr>
      <tr>
        <td><strong>H2O AutoML</strong></td>
        <td>–ë—ã—Å—Ç—Ä—ã–π, –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º—ã–π</td>
        <td>–°–≤–æ–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö</td>
      </tr>
      <tr>
        <td><strong>PyCaret</strong></td>
        <td>–ü—Ä–æ—Å—Ç–æ–π, –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π</td>
        <td>–ú–µ–Ω—å—à–µ –∫–æ–Ω—Ç—Ä–æ–ª—è</td>
      </tr>
      <tr>
        <td><strong>AutoKeras</strong></td>
        <td>–î–ª—è –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π, Keras API</td>
        <td>–¢–æ–ª—å–∫–æ DL</td>
      </tr>
      <tr>
        <td><strong>MLBox</strong></td>
        <td>–î—Ä–µ–π—Ñ –¥–∞–Ω–Ω—ã—Ö, feature engineering</td>
        <td>–ú–µ–Ω—å—à–µ –ø–æ–ø—É–ª—è—Ä–µ–Ω</td>
      </tr>
    </table>
  </div>

  <div class="block">
    <h2>üî∑ 11. –ë–∞–π–µ—Å–æ–≤—Å–∫–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è</h2>
    <p>–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –ø–æ–¥–±–æ—Ä–∞ –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:</p>
    <pre><code># –£—Å—Ç–∞–Ω–æ–≤–∫–∞
# pip install scikit-optimize

from skopt import BayesSearchCV
from skopt.space import Real, Integer, Categorical
from sklearn.ensemble import RandomForestClassifier

# –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –ø–æ–∏—Å–∫–∞
search_spaces = {
    'n_estimators': Integer(10, 200),
    'max_depth': Integer(3, 15),
    'min_samples_split': Integer(2, 20),
    'min_samples_leaf': Integer(1, 10),
    'max_features': Categorical(['sqrt', 'log2', None])
}

# –ë–∞–π–µ—Å–æ–≤—Å–∫–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
opt = BayesSearchCV(
    RandomForestClassifier(random_state=42),
    search_spaces,
    n_iter=50,          # –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π
    cv=5,
    n_jobs=-1,
    random_state=42
)

opt.fit(X_train, y_train)
print(f"Best score: {opt.best_score_:.3f}")
print(f"Best params: {opt.best_params_}")</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 12. Optuna</h2>
    <p>–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π —Ñ—Ä–µ–π–º–≤–æ—Ä–∫ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:</p>
    <pre><code># –£—Å—Ç–∞–Ω–æ–≤–∫–∞
# pip install optuna

import optuna
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score

def objective(trial):
    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    n_estimators = trial.suggest_int('n_estimators', 10, 200)
    max_depth = trial.suggest_int('max_depth', 2, 32)
    min_samples_split = trial.suggest_int('min_samples_split', 2, 20)
    
    # –ú–æ–¥–µ–ª—å
    model = RandomForestClassifier(
        n_estimators=n_estimators,
        max_depth=max_depth,
        min_samples_split=min_samples_split,
        random_state=42
    )
    
    # –û—Ü–µ–Ω–∫–∞
    score = cross_val_score(
        model, X_train, y_train, 
        cv=5, scoring='f1_weighted'
    ).mean()
    
    return score

# –°–æ–∑–¥–∞–Ω–∏–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è
study = optuna.create_study(
    direction='maximize',
    sampler=optuna.samplers.TPESampler(seed=42)
)

# –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
study.optimize(objective, n_trials=100)

# –õ—É—á—à–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
print(f"Best value: {study.best_value:.3f}")
print(f"Best params: {study.best_params}")

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
optuna.visualization.plot_optimization_history(study)
optuna.visualization.plot_param_importances(study)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 13. Hyperopt</h2>
    <pre><code># –£—Å—Ç–∞–Ω–æ–≤–∫–∞
# pip install hyperopt

from hyperopt import hp, fmin, tpe, Trials, STATUS_OK
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.model_selection import cross_val_score

# –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –ø–æ–∏—Å–∫–∞
space = {
    'n_estimators': hp.choice('n_estimators', range(50, 200)),
    'max_depth': hp.choice('max_depth', range(3, 15)),
    'learning_rate': hp.loguniform('learning_rate', -5, 0),
    'subsample': hp.uniform('subsample', 0.5, 1.0)
}

def objective(params):
    model = GradientBoostingClassifier(
        n_estimators=int(params['n_estimators']),
        max_depth=int(params['max_depth']),
        learning_rate=params['learning_rate'],
        subsample=params['subsample'],
        random_state=42
    )
    
    score = cross_val_score(
        model, X_train, y_train, cv=5
    ).mean()
    
    # Hyperopt –º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ—Ç, –ø–æ—ç—Ç–æ–º—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º -score
    return {'loss': -score, 'status': STATUS_OK}

# –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
trials = Trials()
best = fmin(
    fn=objective,
    space=space,
    algo=tpe.suggest,   # Tree-structured Parzen Estimator
    max_evals=100,
    trials=trials
)

print(f"Best params: {best}")</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 14. Neural Architecture Search (NAS)</h2>
    <p>–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π:</p>
    <pre><code># AutoKeras –¥–ª—è NAS
import autokeras as ak

# –ü–æ–∏—Å–∫ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
input_node = ak.ImageInput()
output_node = ak.ImageBlock(
    block_type='resnet',
    normalize=True,
    augment=True
)(input_node)
output_node = ak.ClassificationHead()(output_node)

clf = ak.AutoModel(
    inputs=input_node,
    outputs=output_node,
    max_trials=10
)

clf.fit(x_train, y_train, epochs=10)

# –ò–ª–∏ Keras Tuner
from kerastuner import HyperModel, RandomSearch
import tensorflow as tf

class MyHyperModel(HyperModel):
    def build(self, hp):
        model = tf.keras.Sequential()
        
        # –ü–æ–¥–±–∏—Ä–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ–µ–≤ –∏ –Ω–µ–π—Ä–æ–Ω–æ–≤
        for i in range(hp.Int('num_layers', 1, 5)):
            model.add(tf.keras.layers.Dense(
                units=hp.Int(f'units_{i}', 32, 512, step=32),
                activation='relu'
            ))
        
        model.add(tf.keras.layers.Dense(10, activation='softmax'))
        
        model.compile(
            optimizer='adam',
            loss='sparse_categorical_crossentropy',
            metrics=['accuracy']
        )
        return model

tuner = RandomSearch(
    MyHyperModel(),
    objective='val_accuracy',
    max_trials=10
)

tuner.search(x_train, y_train, epochs=5, validation_split=0.2)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 15. Feature Engineering –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è</h2>
    <pre><code># Featuretools - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
# pip install featuretools

import featuretools as ft
import pandas as pd

# –°–æ–∑–¥–∞–Ω–∏–µ EntitySet
es = ft.EntitySet(id='data')

# –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞
es = es.add_dataframe(
    dataframe_name='transactions',
    dataframe=transactions_df,
    index='transaction_id',
    time_index='timestamp'
)

es = es.add_dataframe(
    dataframe_name='customers',
    dataframe=customers_df,
    index='customer_id'
)

# –°–≤—è–∑—å –º–µ–∂–¥—É —Ç–∞–±–ª–∏—Ü–∞–º–∏
es = es.add_relationship('customers', 'customer_id',
                         'transactions', 'customer_id')

# –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
feature_matrix, feature_defs = ft.dfs(
    entityset=es,
    target_dataframe_name='customers',
    max_depth=2,
    verbose=True
)

print(f"Generated {len(feature_defs)} features")
print(feature_matrix.head())</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 16. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö</h2>
    <pre><code># DataPrep - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞
# pip install dataprep

from dataprep.eda import create_report, plot, plot_correlation

# –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π EDA –æ—Ç—á–µ—Ç
create_report(df).show_browser()

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–∑–Ω–∞–∫–∞
plot(df, 'column_name')

# –ö–æ—Ä—Ä–µ–ª—è—Ü–∏–∏
plot_correlation(df)

# Sklearn ColumnTransformer - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.impute import SimpleImputer
from sklearn.pipeline import Pipeline

# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–æ–≤ –∫–æ–ª–æ–Ω–æ–∫
numeric_features = df.select_dtypes(include=['int64', 'float64']).columns
categorical_features = df.select_dtypes(include=['object']).columns

# –ü–∞–π–ø–ª–∞–π–Ω –¥–ª—è —á–∏—Å–ª–æ–≤—ã—Ö
numeric_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

# –ü–∞–π–ø–ª–∞–π–Ω –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö
categorical_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('onehot', OneHotEncoder(handle_unknown='ignore'))
])

# –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ
preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_transformer, numeric_features),
        ('cat', categorical_transformer, categorical_features)
    ]
)</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 17. –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å AutoML</h2>
    <div class="good-vs-bad">
      <div class="good">
        <h3>‚úÖ –•–æ—Ä–æ—à–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å</h3>
        <ul>
          <li>–ë—ã—Å—Ç—Ä–æ–µ –ø—Ä–æ—Ç–æ—Ç–∏–ø–∏—Ä–æ–≤–∞–Ω–∏–µ</li>
          <li>–ë–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å (baseline)</li>
          <li>–ú–∞–ª—ã–π –æ–ø—ã—Ç –≤ ML</li>
          <li>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è</li>
          <li>–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏ (–∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è, —Ä–µ–≥—Ä–µ—Å—Å–∏—è)</li>
          <li>–¢–∞–±–ª–∏—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</li>
          <li>–ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –¥–∞–Ω–Ω—ã—Ö</li>
        </ul>
      </div>
      <div class="bad">
        <h3>‚ùå –ù–µ –ø–æ–¥—Ö–æ–¥–∏—Ç</h3>
        <ul>
          <li>–ù–µ—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏</li>
          <li>–°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è</li>
          <li>–ù–µ–æ–±—Ö–æ–¥–∏–º –≥–ª—É–±–æ–∫–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å</li>
          <li>–û—á–µ–Ω—å –±–æ–ª—å—à–∏–µ –¥–∞–Ω–Ω—ã–µ (–µ—Å–ª–∏ –Ω–µ H2O)</li>
          <li>–ö—Ä–∏—Ç–∏—á–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å</li>
          <li>–ö–∞—Å—Ç–æ–º–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏</li>
          <li>–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å –≤–∞–∂–Ω–µ–µ —Ç–æ—á–Ω–æ—Å—Ç–∏</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="block">
    <h2>üî∑ 18. –õ—É—á—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏ AutoML</h2>
    <ul>
      <li><strong>–ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞</strong>: –æ—á–∏—Å—Ç–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–¥ AutoML</li>
      <li><strong>–í—Ä–µ–º—è</strong>: –¥–∞—Ç—å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞</li>
      <li><strong>–í–∞–ª–∏–¥–∞—Ü–∏—è</strong>: –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–∞ hold-out set</li>
      <li><strong>–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è</strong>: –ø–æ–Ω—è—Ç—å, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –º–æ–¥–µ–ª—å</li>
      <li><strong>Baseline</strong>: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–Ω—É—é —Ç–æ—á–∫—É</li>
      <li><strong>–ò—Ç–µ—Ä–∞—Ü–∏—è</strong>: –¥–æ—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –≤—Ä—É—á–Ω—É—é –ª—É—á—à–∏–µ –º–æ–¥–µ–ª–∏</li>
      <li><strong>–†–µ—Å—É—Ä—Å—ã</strong>: –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä–æ–≤–∞—Ç—å –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã–µ –∑–∞—Ç—Ä–∞—Ç—ã</li>
      <li><strong>–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è</strong>: —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã</li>
    </ul>
  </div>

  <div class="block">
    <h2>üî∑ 19. –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è AutoML</h2>
    <ul>
      <li><strong>–ß–µ—Ä–Ω—ã–π —è—â–∏–∫</strong>: –Ω–µ –≤—Å–µ–≥–¥–∞ –ø–æ–Ω—è—Ç–Ω–æ, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç</li>
      <li><strong>–í—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã</strong>: –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ—Ä–æ–≥–æ</li>
      <li><strong>–í—Ä–µ–º—è</strong>: –∏–Ω–æ–≥–¥–∞ –¥–æ–ª–≥–æ–µ –æ–±—É—á–µ–Ω–∏–µ</li>
      <li><strong>–ü–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ</strong>: –º–æ–∂–µ—Ç –ø–µ—Ä–µ–æ–±—É—á–∏—Ç—å—Å—è –Ω–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</li>
      <li><strong>–°–ø–µ—Ü–∏—Ñ–∏–∫–∞ –¥–æ–º–µ–Ω–∞</strong>: –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç –¥–æ–º–µ–Ω–Ω—ã–µ –∑–Ω–∞–Ω–∏—è</li>
      <li><strong>–ö–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏—è</strong>: —Å–ª–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–≤–æ–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã</li>
      <li><strong>–í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç—å</strong>: –Ω–µ –≤—Å–µ–≥–¥–∞ –ª–µ–≥–∫–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏</li>
    </ul>
  </div>

  <div class="block">
    <h2>üî∑ 20. Workflow —Å AutoML</h2>
    <ol>
      <li><strong>–ê–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö</strong>: EDA, –ø–æ–Ω–∏–º–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö</li>
      <li><strong>–û—á–∏—Å—Ç–∫–∞</strong>: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–ø—É—Å–∫–æ–≤, –≤—ã–±—Ä–æ—Å–æ–≤</li>
      <li><strong>–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ</strong>: train/val/test split</li>
      <li><strong>AutoML</strong>: –∑–∞–ø—É—Å–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è</li>
      <li><strong>–ê–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</strong>: –∏–∑—É—á–µ–Ω–∏–µ –ª—É—á—à–∏—Ö –º–æ–¥–µ–ª–µ–π</li>
      <li><strong>–í–∞–ª–∏–¥–∞—Ü–∏—è</strong>: –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ test set</li>
      <li><strong>–î–æ—Ä–∞–±–æ—Ç–∫–∞</strong>: —Ä—É—á–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏</li>
      <li><strong>Feature engineering</strong>: –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–µ–Ω–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤</li>
      <li><strong>–ü–æ–≤—Ç–æ—Ä–Ω—ã–π –∑–∞–ø—É—Å–∫</strong>: AutoML —Å –Ω–æ–≤—ã–º–∏ –ø—Ä–∏–∑–Ω–∞–∫–∞–º–∏</li>
      <li><strong>–§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è</strong>: –≤—ã–±–æ—Ä –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏</li>
    </ol>
  </div>

  <div class="block">
    <h2>üî∑ 21. –ú–µ—Ç—Ä–∏–∫–∏ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥</h2>
    <pre><code># –ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ AutoML —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–≤ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –∫–∞—Å—Ç–æ–º–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏

# PyCaret - –∫–∞—Å—Ç–æ–º–Ω–∞—è –º–µ—Ç—Ä–∏–∫–∞
from pycaret.classification import setup, compare_models

def custom_metric(y_true, y_pred):
    # –í–∞—à–∞ –º–µ—Ç—Ä–∏–∫–∞
    return score

setup(data=df, target='target', 
      custom_metric=custom_metric)

# Optuna - –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–µ—Ç—Ä–∏–∫
def multi_objective(trial):
    # ... –ø–∞—Ä–∞–º–µ—Ç—Ä—ã ...
    model = ...
    
    accuracy = ...
    f1 = ...
    
    return accuracy, f1  # –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ü–µ–ª–µ–π

study = optuna.create_study(directions=['maximize', 'maximize'])
study.optimize(multi_objective, n_trials=100)

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —á–µ—Ä–µ–∑ Weights & Biases
import wandb
from wandb.keras import WandbCallback

wandb.init(project="automl-experiment")
# –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –º–µ—Ç—Ä–∏–∫
wandb.log({"accuracy": accuracy, "loss": loss})</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 22. –ü—Ä–æ–¥–∞–∫—à–Ω –∏ –¥–µ–ø–ª–æ–π</h2>
    <pre><code># –≠–∫—Å–ø–æ—Ä—Ç –º–æ–¥–µ–ª–∏ –∏–∑ AutoML
# TPOT
tpot.export('best_pipeline.py')

# PyCaret
save_model(model, 'my_automl_model')

# H2O
h2o.save_model(model, path="./models/")

# –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
# PyCaret
from pycaret.classification import load_model, predict_model

model = load_model('my_automl_model')
predictions = predict_model(model, data=new_data)

# H2O
loaded_model = h2o.load_model("./models/model_name")
predictions = loaded_model.predict(h2o_test_frame)

# –£–ø–∞–∫–æ–≤–∫–∞ –≤ Docker
# Dockerfile
FROM python:3.9
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY model.pkl .
COPY app.py .
CMD ["python", "app.py"]</code></pre>
  </div>

  <div class="block">
    <h2>üî∑ 23. –í—ã–±–æ—Ä AutoML —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–∞</h2>
    <p><strong>–î–ª—è –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö</strong>: PyCaret (–ø—Ä–æ—Å—Ç–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å)</p>
    <p><strong>–î–ª—è —Ç–∞–±–ª–∏—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö</strong>: H2O AutoML –∏–ª–∏ Auto-sklearn</p>
    <p><strong>–î–ª—è –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π</strong>: AutoKeras –∏–ª–∏ Keras Tuner</p>
    <p><strong>–î–ª—è –≥–∏–±–∫–æ—Å—Ç–∏</strong>: Optuna –∏–ª–∏ Hyperopt</p>
    <p><strong>–î–ª—è –±–æ–ª—å—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö</strong>: H2O AutoML</p>
    <p><strong>–î–ª—è research</strong>: Auto-sklearn –∏–ª–∏ TPOT</p>
    <p><strong>–î–ª—è –ø—Ä–æ–¥–∞–∫—à–Ω–∞</strong>: H2O –∏–ª–∏ PyCaret</p>
  </div>

  <div class="block">
    <h2>üî∑ 24. –ß–µ–∫-–ª–∏—Å—Ç AutoML –ø—Ä–æ–µ–∫—Ç–∞</h2>
    <ul>
      <li>[ ] –ü—Ä–æ–≤–µ—Å—Ç–∏ EDA –∏ –ø–æ–Ω—è—Ç—å –¥–∞–Ω–Ω—ã–µ</li>
      <li>[ ] –û—á–∏—Å—Ç–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ—Ç —è–≤–Ω—ã—Ö –æ—à–∏–±–æ–∫</li>
      <li>[ ] –†–∞–∑–¥–µ–ª–∏—Ç—å –Ω–∞ train/val/test</li>
      <li>[ ] –í—ã–±—Ä–∞—Ç—å AutoML —Ñ—Ä–µ–π–º–≤–æ—Ä–∫</li>
      <li>[ ] –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –º–µ—Ç—Ä–∏–∫—É –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏</li>
      <li>[ ] –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Ä–µ–º—è/—Ä–µ—Å—É—Ä—Å—ã –¥–ª—è –ø–æ–∏—Å–∫–∞</li>
      <li>[ ] –ó–∞–ø—É—Å—Ç–∏—Ç—å AutoML</li>
      <li>[ ] –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏</li>
      <li>[ ] –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞ test set</li>
      <li>[ ] –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã</li>
      <li>[ ] –î–æ–±–∞–≤–∏—Ç—å –¥–æ–º–µ–Ω–Ω—ã–µ –∑–Ω–∞–Ω–∏—è</li>
      <li>[ ] –ü–æ–≤—Ç–æ—Ä–∏—Ç—å —Å —É–ª—É—á—à–µ–Ω–∏—è–º–∏</li>
      <li>[ ] –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏ –∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å</li>
    </ul>

    <h3>üí° –û–±—ä—è—Å–Ω–µ–Ω–∏–µ –∑–∞–∫–∞–∑—á–∏–∫—É:</h3>
    <blockquote>
      ¬´AutoML ‚Äî —ç—Ç–æ –∫–∞–∫ –æ–ø—ã—Ç–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç —Å–æ—Ç–Ω–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫, –Ω–∞—Ö–æ–¥—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö. –≠—Ç–æ —ç–∫–æ–Ω–æ–º–∏—Ç –Ω–µ–¥–µ–ª–∏ —Ä—É—á–Ω–æ–π —Ä–∞–±–æ—Ç—ã –∏ –¥–∞–µ—Ç –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±—ã—Å—Ç—Ä–æ¬ª.
    </blockquote>
  </div>

</div>

</body>
</html>
